<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="abc_action_bar_home_description">Navigate home</string>
    <string name="abc_action_bar_home_description_format">%1$s, %2$s</string>
    <string name="abc_action_bar_home_subtitle_description_format">%1$s, %2$s, %3$s</string>
    <string name="abc_action_bar_up_description">Navigate up</string>
    <string name="abc_action_menu_overflow_description">More options</string>
    <string name="abc_action_mode_done">Done</string>
    <string name="abc_activity_chooser_view_see_all">See all</string>
    <string name="abc_activitychooserview_choose_application">Choose an app</string>
    <string name="abc_capital_off">OFF</string>
    <string name="abc_capital_on">ON</string>
    <string name="abc_search_hint">Search…</string>
    <string name="abc_searchview_description_clear">Clear query</string>
    <string name="abc_searchview_description_query">Search query</string>
    <string name="abc_searchview_description_search">Search</string>
    <string name="abc_searchview_description_submit">Submit query</string>
    <string name="abc_searchview_description_voice">Voice search</string>
    <string name="abc_shareactionprovider_share_with">Share with</string>
    <string name="abc_shareactionprovider_share_with_application">Share with %s</string>
    <string name="abc_toolbar_collapse_description">Collapse</string>
    <string name="com_facebook_device_auth_instructions">Visit &lt;b>facebook.com/device&lt;/b> and enter the code shown above.</string>
    <string name="com_facebook_image_download_unknown_error">Unexpected error while downloading an image.</string>
    <string name="com_facebook_internet_permission_error_message">WebView login requires INTERNET permission</string>
    <string name="com_facebook_internet_permission_error_title">AndroidManifest Error</string>
    <string name="com_facebook_like_button_liked">Liked</string>
    <string name="com_facebook_like_button_not_liked">Like</string>
    <string name="com_facebook_loading">Loading…</string>
    <string name="com_facebook_loginview_cancel_action">Cancel</string>
    <string name="com_facebook_loginview_log_in_button">Log in</string>
    <string name="com_facebook_loginview_log_in_button_continue">Continue with Facebook</string>
    <string name="com_facebook_loginview_log_in_button_long">Log in with Facebook</string>
    <string name="com_facebook_loginview_log_out_action">Log out</string>
    <string name="com_facebook_loginview_log_out_button">Log out</string>
    <string name="com_facebook_loginview_logged_in_as">Logged in as: %1$s</string>
    <string name="com_facebook_loginview_logged_in_using_facebook">Logged in using Facebook</string>
    <string name="com_facebook_send_button_text">Send</string>
    <string name="com_facebook_share_button_text">Share</string>
    <string name="com_facebook_smart_device_instructions">To connect your account, open the Facebook app on your mobile device and check for notifications.</string>
    <string name="com_facebook_smart_device_instructions_or">- OR -</string>
    <string name="com_facebook_smart_login_confirmation_cancel">Not you?</string>
    <string name="com_facebook_smart_login_confirmation_title">Confirm Login</string>
    <string name="com_facebook_tooltip_default">"You're in control - choose what info you want to share with apps."</string>
    <string name="common_google_play_services_api_unavailable_text">%1$s requires one or more Google Play services that are not currently available. Please contact the developer for assistance.</string>
    <string name="common_google_play_services_enable_button">Enable Google Play services</string>
    <string name="common_google_play_services_enable_text">"%1$s won't work unless you enable Google Play services."</string>
    <string name="common_google_play_services_enable_title">Enable Google Play services</string>
    <string name="common_google_play_services_install_button">Get Google Play services</string>
    <string name="common_google_play_services_install_text_phone">"%1$s won't run without Google Play services, which are missing from your phone."</string>
    <string name="common_google_play_services_install_text_tablet">"%1$s won't run without Google Play services, which are missing from your tablet."</string>
    <string name="common_google_play_services_install_title">Get Google Play services</string>
    <string name="common_google_play_services_invalid_account_text">The specified account does not exist on this device. Please choose a different account.</string>
    <string name="common_google_play_services_invalid_account_title">Invalid Account</string>
    <string name="common_google_play_services_network_error_text">A data connection is required to connect to Google Play services.</string>
    <string name="common_google_play_services_network_error_title">Network Error</string>
    <string name="common_google_play_services_notification_ticker">Google Play services error</string>
    <string name="common_google_play_services_resolution_required_text">Please complete action required by %1$s.</string>
    <string name="common_google_play_services_resolution_required_title">Google Play services requires an action</string>
    <string name="common_google_play_services_restricted_profile_text">Accessing accounts from a restricted profile is not supported.</string>
    <string name="common_google_play_services_restricted_profile_title">Restricted Profile</string>
    <string name="common_google_play_services_sign_in_failed_text">Error signing in the specified account. Please choose a different account.</string>
    <string name="common_google_play_services_sign_in_failed_title">Sign in failed</string>
    <string name="common_google_play_services_unknown_issue">%1$s is having trouble with Google Play services. If the problem persists, please contact the developer for assistance.</string>
    <string name="common_google_play_services_unsupported_text">%1$s relies on Google Play services, which is not supported by your device. Contact the manufacturer for assistance.</string>
    <string name="common_google_play_services_unsupported_title">Google Play services</string>
    <string name="common_google_play_services_update_button">Update</string>
    <string name="common_google_play_services_update_text">"%1$s won't run unless you update Google Play services."</string>
    <string name="common_google_play_services_update_title">Update Google Play services</string>
    <string name="common_google_play_services_updating_text">"%1$s won't run without Google Play services, which are currently updating."</string>
    <string name="common_google_play_services_updating_title">Google Play services are updating</string>
    <string name="common_google_play_services_wear_update_text">New version of Google Play services needed. It will update itself shortly.</string>
    <string name="common_open_on_phone">Open on phone</string>
    <string name="common_signin_button_text">Sign in</string>
    <string name="common_signin_button_text_long">Sign in with Google</string>
    <string name="messenger_send_button_text">Send</string>
    <string name="search_menu_title">Search</string>
    <string name="status_bar_notification_info_overflow">999+</string>
    <string name="com_facebook_smart_login_confirmation_continue_as">Continue as %1$s</string>
    <string name="AStarSearch">A* 算法</string>
    <string name="AStarSearch0">"The \"A*\" (pronounced A Star) algorithm was an advancement of Dijkstra's algorithm. First, let's find the shortest path in this maze using Dijkstra's algorithm."</string>
    <string name="AStarSearch1">In this maze, we can infer that the cost between nodes on the graph is 1.</string>
    <string name="AStarSearch10">"It might be easier to understand if we think of the estimated cost numbers we just set as representing each point's altitude."</string>
    <string name="AStarSearch100">"By setting an appropriate estimated cost based on what's known in advance and giving it as a hint, more efficient searches become possible."</string>
    <string name="AStarSearch101">Taking the actual cost from the starting point to our current location + the estimated cost from our current location to the goal gives us the cost from the starting point to the goal.</string>
    <string name="AStarSearch11">The goal in the lower right would be the lowest point, and the point in the upper left with a cost of 8 would be the highest point. Walking down a hill always feels easier than climbing one.</string>
    <string name="AStarSearch12">When exploring the maze, if we make it easier to move in the direction of lower cost like it is to move downhill, we should be able to reach the goal quickly.</string>
    <string name="AStarSearch13">"Now, let's try solving the maze using A*."</string>
    <string name="AStarSearch14">First, we consider the start location fully explored.</string>
    <string name="AStarSearch15">We then calculate the cost of each point that we can move to from the start location.</string>
    <string name="AStarSearch16">This cost is calculated as the total of the cost of moving to that point and the estimated cost to the goal.</string>
    <string name="AStarSearch17">We choose one of the points with the lowest cost.</string>
    <string name="AStarSearch18">The point chosen is considered to be fully explored.</string>
    <string name="AStarSearch19">Again we calculate the cost of each point that we can move to next from the fully explored point.</string>
    <string name="AStarSearch2">"Under that premise, let's use Dijkstra's algorithm to find the shortest path."</string>
    <string name="AStarSearch20">And once more we choose one of the points with the lowest cost.</string>
    <string name="AStarSearch21">The point chosen is considered to be fully explored.</string>
    <string name="AStarSearch22">Hereafter, the same operations repeat until the goal is reached.</string>
    <string name="AStarSearch24">"Compared to using Dijkstra's algorithm, we were able to explore the maze more efficiently."</string>
    <string name="AStarSearch25">What can we do to solve the maze even more efficiently?</string>
    <string name="AStarSearch26">"Let's try using the actual cost of the shortest path instead of linear distance."</string>
    <string name="AStarSearch28">This time, we reached the goal by taking the shortest path without taking any unnecessary paths at all.</string>
    <string name="AStarSearch29">"Realistically, there isn't a time when we'll know the actual cost of the shortest path. If we already knew the shortest path, there would be no reason to search in the first place."</string>
    <string name="AStarSearch30">As you can see, how you set the heuristic cost becomes the crucial factor for adjusting A*.</string>
    <string name="AStarSearch31">The closer the heuristic cost is to the actual cost of the shortest path, the more efficiently the maze can be solved.</string>
    <string name="AStarSearch32">"On the other hand, let's take a look at what happens when an adjustment to the heuristic cost fails."</string>
    <string name="AStarSearch33">"Here, as an extreme example, we've only left the heuristic cost on the shortest path and set all other cost values to 0."</string>
    <string name="AStarSearch35">"The efficiency of the search was even worse than using Dijkstra's algorithm. However, the shortest path was still found correctly."</string>
    <string name="AStarSearch36">With A*, as long as the heuristic cost is less than or equal to the lowest cost from the current point to the goal, finding the shortest path in the maze is guaranteed, regardless of efficiency.</string>
    <string name="AStarSearch37">"As a bad example, let's try setting the heuristic cost to something larger than the lowest cost from the current point to the goal."</string>
    <string name="AStarSearch38">"Here we have left only the shortest path's heuristic cost and set it to double its previous value. In doing so, we have far exceeded the lowest cost from the current point to the goal."</string>
    <string name="AStarSearch4">The shortest path was found, but involved traversing practically every path.</string>
    <string name="AStarSearch40">The algorithm decided that its search was over, but the path it found differed from the shortest path.</string>
    <string name="AStarSearch41">In this way, we see that how you make your adjustments determines whether or not A* is a good algorithm.</string>
    <string name="AStarSearch42">It is often used in game programming for things such as enemy AI that follows the player.</string>
    <string name="AStarSearch43">"However, the algorithm's large number of calculations can have a negative effect on the overall speed of the game. You'll need to think about how to use it, whether that be combining it with other algorithms or restricting its use."</string>
    <string name="AStarSearch44">This concludes the explanation of the A* algorithm.</string>
    <string name="AStarSearch5">"Dijkstra's algorithm only takes into account the cost from the starting point before deciding which node to move to next."</string>
    <string name="AStarSearch6">"Because of that, it goes down paths like the ones marked with arrows, not realizing they're going farther away from the goal."</string>
    <string name="AStarSearch7">A* considers not only the cost from the starting point, but the estimated cost from the current point to the goal as well.</string>
    <string name="AStarSearch8">This estimated cost can be freely set. In this case, the values used were determined by rounding the linear distance from the goal in the lower right.</string>
    <string name="AStarSearch9">This estimated cost manually set in advance is known as the \"heuristic cost\".</string>
    <string name="AStarSearchDescription">"The \"A*\" algorithm is a more advanced version of Dijkstra's algorithm. You can study this topic after purchasing all of the algorithms."</string>
    <string name="AboutDev">关于应用</string>
    <string name="AlgorithmText1">RSA加密</string>
    <string name="AlgorithmText2">Elliptic Curve Cryptography</string>
    <string name="AlreadyBought">购买</string>
    <string name="AlreadyBoughtRestore">"If you've reinstalled the app or installed it on another iOS device, please use the \"Restore purchase records\" option."</string>
    <string name="AlreadyBoughtRestoreAndroid">"If you've reinstalled the app or installed it on another Android device, please use the \"Restore purchase records\" option."</string>
    <string name="AppTitle">算法详解: 讲解 + 动画演示</string>
    <string name="Array">数组</string>
    <string name="Array0">\"Arrays\" are one type of data structure, and can store multiple values.</string>
    <string name="Array1">Each element can be accessed through its index (a number that denotes its order within the data).</string>
    <string name="Array10">First we secure an additional space at the end of the array.</string>
    <string name="Array11">In order to free up the space needed for the addition, data is shifted one element at a time.</string>
    <string name="Array13">\"Green\" is added to the empty space, completing the addition.</string>
    <string name="Array14">Conversely, when deleting the second element,</string>
    <string name="Array15">we first delete the element,</string>
    <string name="Array16">then fill in the empty space by shifting the data one element at a time.</string>
    <string name="Array18">Finally, the extra space is deleted, completing the deletion.</string>
    <string name="Array19">This concludes the explanation of arrays.</string>
    <string name="Array2">Data is stored sequentially in memory in consecutive locations.</string>
    <string name="Array3">"Because they're stored in consecutive locations, memory addresses can be calculated using their indices, allowing for random access of data."</string>
    <string name="Array8">Another feature of arrays is that adding or deleting data in a specific location carries a high cost compared to lists.</string>
    <string name="Array9">"Let's imagine adding \"Green\" to the 2nd location."</string>
    <string name="BellmanFord">Bellman-Ford(贝尔曼-福特)算法</string>
    <string name="BellmanFord0">The \"Bellman-Ford algorithm\" is an algorithm that finds the shortest path on a graph.</string>
    <string name="BellmanFord1">An initial cost value is assigned to each point. The starting point is set to 0, and all other points are set to infinity.</string>
    <string name="BellmanFord10">Moving on, we calculate the opposite direction of getting from point B to point A.</string>
    <string name="BellmanFord11">"Point B's cost is 9, so the cost of getting from point B to point A is 9 + 9 = 18."</string>
    <string name="BellmanFord12">"When we compare this with point A's current value, its current value is found to be lower, so the cost isn't updated."</string>
    <string name="BellmanFord13">"When moving from a point with higher cost to a point with lower cost, that edge's cost doesn't get updated as long as its cost is positive."</string>
    <string name="BellmanFord14">"The same operations will be performed on all edges. The order of the edges is up to us, but this time, for convenience, we'll make calculations starting from the edges on the left side."</string>
    <string name="BellmanFord15">We select an edge...</string>
    <string name="BellmanFord150">For example, the shortest paths to point C (1 move) and point D (2 moves) have been found.</string>
    <string name="BellmanFord16">and update the cost.</string>
    <string name="BellmanFord17">Likewise, we select another edge...</string>
    <string name="BellmanFord18">and update the cost.</string>
    <string name="BellmanFord19">Now we see that if going from point A to point B, the cost is actually lower to go through point C than to go from point A directly.</string>
    <string name="BellmanFord2">"One of the edges is selected. For convenience, we've selected the A-B edge."</string>
    <string name="BellmanFord20">The cost updates are performed on all edges.</string>
    <string name="BellmanFord21">One round of updates was made.</string>
    <string name="BellmanFord22">The update operation is repeated on all edges until no more cost updates occur.</string>
    <string name="BellmanFord24">No more cost updates occur, so we stop the operation.</string>
    <string name="BellmanFord25">"At this point, the algorithm's search finishes, and the shortest path from the starting point to each other point has been found."</string>
    <string name="BellmanFord26">"Let's think about why the shortest path gets found by such operations."</string>
    <string name="BellmanFord27">The scene has been returned to its initial state.</string>
    <string name="BellmanFord28">"This time, let's carry out the update operation for all edges in the opposite order, in other words, from the edges on the right side, so that the edges coming from the starting point, A, are updated last."</string>
    <string name="BellmanFord3">The cost of each traversal from end point to end point on the selected edge is calculated. The calculation is performed by taking the cost of the initial point + the cost of moving.</string>
    <string name="BellmanFord30">One round of updates was made.</string>
    <string name="BellmanFord31">We can see that after 1 round of updates, only the costs for the points reachable from starting point A in 1 move have been updated.</string>
    <string name="BellmanFord32">"We'll try a second round of updates."</string>
    <string name="BellmanFord34">The second round of updates has finished.</string>
    <string name="BellmanFord35">We can see that after 2 rounds of updates, only the costs for the points reachable from the starting point in 2 moves have been updated.</string>
    <string name="BellmanFord36">Actually, after performing the update operation N times, it is guaranteed that the shortest paths will be found for all points N moves or fewer away from starting point A.</string>
    <string name="BellmanFord37">The diagram has had two rounds of updates, so the shortest paths from the starting point to all points 2 moves or fewer away will have been found at the very least.</string>
    <string name="BellmanFord38">"The shortest paths are only for points 2 moves or fewer away, so even though the path to point F via A-C-D-F has a lower cost, it requires 3 moves, and so isn't considered."</string>
    <string name="BellmanFord39">Also, although the shortest path to point B has been found to take 3 moves, this just happened to be discovered due to the order in which the edges were updated.</string>
    <string name="BellmanFord4">"Calculation is carried out one direction at a time. While either direction is fine, for convenience, in this explanation we'll first calculate the direction from the point with the smaller cost to the point with the larger cost."</string>
    <string name="BellmanFord40">In other words, depending on the order in which the edges are updated, there are times when shortest paths are discovered that require more moves than the number of update rounds.</string>
    <string name="BellmanFord41">So, given that the shortest paths N moves or fewer away are found after N update operations have been carried out, how many times should we carry out the update operation?</string>
    <string name="BellmanFord42">"Given N points, and given that the same point isn't arrived back at, we're assured to be able to arrive at all points in N - 1 moves."</string>
    <string name="BellmanFord43">In other words, if we carry out N - 1 update operations at the very most, the shortest paths to all points will be found.</string>
    <string name="BellmanFord44">Also, if along the way there were no more updates to be made, we could say that the shortest paths have all been determined, and the operation would end there.</string>
    <string name="BellmanFord45">"Now, let's resume the update operations for the diagram until the shortest paths to all points have been found."</string>
    <string name="BellmanFord47">There are no more updates to be made, so the operation is stopped.</string>
    <string name="BellmanFord48">We were able to derive the shortest paths to all points, just like before.</string>
    <string name="BellmanFord49">Moreover, even if the cost differs between the coming and going paths between A and B, as in the graph, and even if only one-way travel is possible, as in the case of the other edges...</string>
    <string name="BellmanFord5">"The current cost of point A is lower, so we'll calculate the traversal from point A to point B first."</string>
    <string name="BellmanFord50">the Bellman-Ford algorithm can correctly find the shortest paths.</string>
    <string name="BellmanFord51">Graphs where the direction of the edges is fixed, as in the diagram, are called \"directed graphs\", and graphs where the direction of the edges is not fixed are called \"undirected graphs\".</string>
    <string name="BellmanFord52">So, what happens when there are some \"negative costs\" as well?</string>
    <string name="BellmanFord53">\"Negative cost\" would refer to the -3 on the C-B edge in the diagram.</string>
    <string name="BellmanFord54">"It's difficult to imagine what it means for the cost to be a negative value..."</string>
    <string name="BellmanFord55">"but as an example, let's imagine moving in a car from starting point A to end point G. We can think of each cost as expressing the amount of fuel consumed."</string>
    <string name="BellmanFord56">In that situation, if we think of there being a gas station where we can replenish our fuel in the area with negative cost, it might be easier to understand.</string>
    <string name="BellmanFord57">With the Bellman-Ford algorithm, even in situations like this that incorporate negative cost, the shortest paths are correctly found.</string>
    <string name="BellmanFord58">So, what would happen if the negative cost of the C-B edge in the graph went from -3 to -6?</string>
    <string name="BellmanFord59">It would appear that the shortest path would be found without issue...</string>
    <string name="BellmanFord6">"Point A's cost is 0, so the cost of getting from point A to point B is 0 + 9 = 9."</string>
    <string name="BellmanFord60">but the total cost for a round trip between A-C-B is -1.</string>
    <string name="BellmanFord61">Paths like this are called \"negative cycles\".</string>
    <string name="BellmanFord62">"When there's a negative cycle, you can make the cost lower and lower without end by continuing in circles around it."</string>
    <string name="BellmanFord63">"Thus, there's no way to find the shortest path."</string>
    <string name="BellmanFord64">"When trying to find the shortest path in this graph with the Bellman-Ford algorithm, no matter how many times you carry out updates, some point's value will change, so it never finishes."</string>
    <string name="BellmanFord65">Actually, with the Bellman-Ford algorithm, updates should be complete after (number of points - 1) operations, so...</string>
    <string name="BellmanFord66">"if the number of updates meets or exceeds N times, that means there's a negative cycle somewhere in the graph."</string>
    <string name="BellmanFord67">As you just saw, the Bellman-Ford algorithm is an algorithm with a large amount of calculations, but it can find the shortest paths even when there are negative costs...</string>
    <string name="BellmanFord68">and it can also detect when there is a negative cycle.</string>
    <string name="BellmanFord69">This concludes the explanation of the Bellman-Ford algorithm.</string>
    <string name="BellmanFord7">If the calculated result is lower than the current value, the cost is updated to the new value.</string>
    <string name="BellmanFord8">"Point B's current value is infinity, so its cost is updated to 9."</string>
    <string name="BellmanFord9">When a value is updated, we record the path and which point it came from. In the diagram, the path is displayed in orange.</string>
    <string name="BinarySearch">二分查找</string>
    <string name="BinarySearch0">\"Binary search\" is an algorithm for searching through elements of a presorted array.</string>
    <string name="BinarySearch1">"Let's try searching for the number 6."</string>
    <string name="BinarySearch10">"We look at the number in the center of the remaining array. This time it's 6."</string>
    <string name="BinarySearch11">6 = 6, so we found the number we were looking for.</string>
    <string name="BinarySearch12">In this way, we see that binary search makes use of a presorted array and continuously halves the numbers to search through, allowing it to search for numbers efficiently.</string>
    <string name="BinarySearch13">This concludes the explanation of binary search.</string>
    <string name="BinarySearch2">"First, we look at the number in the center of the array. In this case it's 5."</string>
    <string name="BinarySearch3">"We compare 5 to the number 6 that we're searching for. Because 5 is less than 6, we know that the number 6 is to the right of 5."</string>
    <string name="BinarySearch4">From the candidates, we remove numbers that are no longer needed.</string>
    <string name="BinarySearch6">"Again we look at the number in the center of the remaining array. This time it's 7."</string>
    <string name="BinarySearch7">We compare 7 to 6. Because 6 is less than 7, we know that the number 6 is to the left of 7.</string>
    <string name="BinarySearch8">From the candidates, we remove numbers that are no longer needed.</string>
    <string name="BinaryTree">二叉搜索树</string>
    <string name="BinaryTree0">\"Binary search trees\" are one type of data structure.</string>
    <string name="BinaryTree1">The numbered points are called \"nodes\".</string>
    <string name="BinaryTree10">"Conversely, a binary search tree's largest node is located at the end of the rightmost subtree line stemming from the topmost node."</string>
    <string name="BinaryTree11">"Let's take a look at the process of adding nodes to a binary search tree."</string>
    <string name="BinaryTree12">"As an example, we'll try adding a 1."</string>
    <string name="BinaryTree13">"We start at the topmost node of the binary search tree in order to find the additional node's proper location."</string>
    <string name="BinaryTree14">1 is less than 15, so it proceeds to the left.</string>
    <string name="BinaryTree16">1 is less than 9, so again it proceeds to the left.</string>
    <string name="BinaryTree18">"1 is less than 3, so it will proceed to the left once more, but since there isn't a node to move to, the 1 is added as a new node."</string>
    <string name="BinaryTree2">Binary search trees have two properties.</string>
    <string name="BinaryTree20">The addition of the 1 is now complete.</string>
    <string name="BinaryTree21">"Next, let's try adding a 4."</string>
    <string name="BinaryTree22">"Like before, we start at the topmost node of the binary search tree in order to find the additional node's proper location."</string>
    <string name="BinaryTree23">4 is less than 15, so it proceeds to the left.</string>
    <string name="BinaryTree25">4 is less than 9, so again it proceeds to the left.</string>
    <string name="BinaryTree27">4 is greater than 3, so it proceeds to the right.</string>
    <string name="BinaryTree29">"4 is less than 8, so it will proceed to the left, but since there isn't a node to move to, the 4 is added as a new node."</string>
    <string name="BinaryTree3">Their first property is that all nodes are greater than the nodes in their left subtree.</string>
    <string name="BinaryTree31">The addition of the 4 is now complete.</string>
    <string name="BinaryTree32">"Now let's look at the process for deleting nodes from a binary search tree."</string>
    <string name="BinaryTree33">"As an example, let's try deleting the 28."</string>
    <string name="BinaryTree34">When the node has no children...</string>
    <string name="BinaryTree35">the target node is simply deleted and the process is complete.</string>
    <string name="BinaryTree36">"Next, let's try deleting the 8."</string>
    <string name="BinaryTree37">When deleting a node that only has 1 child...</string>
    <string name="BinaryTree38">the target node is deleted...</string>
    <string name="BinaryTree39">and when the child node gets moved to the location of the deleted node, the process is complete.</string>
    <string name="BinaryTree4">For example, node 9 is greater than the other numbers in its left subtree.</string>
    <string name="BinaryTree40">"Lastly, let's try deleting the 9."</string>
    <string name="BinaryTree41">When deleting a node that has two children...</string>
    <string name="BinaryTree42">first we delete the target node...</string>
    <string name="BinaryTree43">"and from the deleted node's left subtree we find the largest node..."</string>
    <string name="BinaryTree44">"and move it to the deleted node's location."</string>
    <string name="BinaryTree45">By doing this, we were able to delete a node while preserving the integrity of the binary search tree.</string>
    <string name="BinaryTree46">Furthermore, if the node that was moved also had its own child nodes, the same process is repeated recursively.</string>
    <string name="BinaryTree47">Also, while we used the largest node from the left subtree this time, using the smallest node from the right subtree works as well.</string>
    <string name="BinaryTree48">"This time, let's take a look at the process for searching for a node within a binary search tree."</string>
    <string name="BinaryTree49">"As an example, let's try searching for the 12."</string>
    <string name="BinaryTree5">Likewise, node 15 is greater than the other numbers in its left subtree.</string>
    <string name="BinaryTree50">We start our search at the topmost node of the binary search tree.</string>
    <string name="BinaryTree51">12 is less than 15, so we proceed to the left.</string>
    <string name="BinaryTree53">12 is greater than 4, so we proceed to the right.</string>
    <string name="BinaryTree55">We found the 12.</string>
    <string name="BinaryTree56">"As you can see, we're able to search efficiently using a binary search tree."</string>
    <string name="BinaryTree57">However, if the tree gets close to forming a straight line, its search efficiency becomes extremely poor, like a linear search.</string>
    <string name="BinaryTree58">On the other hand, binary search trees that are always well-balanced, called \"self-balancing binary search trees\", are able to maintain search efficiency.</string>
    <string name="BinaryTree59">This concludes the explanation of binary search trees.</string>
    <string name="BinaryTree6">On the contrary, their second property is that all nodes are smaller than the nodes in their right subtree.</string>
    <string name="BinaryTree7">For example, node 15 is smaller than the other numbers in its right subtree.</string>
    <string name="BinaryTree8">Because of these two properties, the following holds true.</string>
    <string name="BinaryTree9">"First, a binary search tree's smallest node is located at the end of the leftmost subtree line stemming from the topmost node."</string>
    <string name="BinaryTreeDescription">\"Binary search trees\" are the most basic of search trees. You can study this topic after purchasing all of the algorithms.</string>
    <string name="BreadthFirstSearch">广度优先查找</string>
    <string name="BreadthFirstSearch0">\"Breadth-first search\" is an algorithm that searches through graphs.</string>
    <string name="BreadthFirstSearch1">"We'll begin the search with A as the starting point and G as the goal."</string>
    <string name="BreadthFirstSearch11">Among the candidates, C and D were the first ones added. Between those two, we select C from the left side.</string>
    <string name="BreadthFirstSearch12">We move to the selected point.</string>
    <string name="BreadthFirstSearch13">H, reachable from the current point, C, is added as a new candidate.</string>
    <string name="BreadthFirstSearch14">Hereafter, the same operations are repeated until the goal is reached or all of the points have been fully searched.</string>
    <string name="BreadthFirstSearch2">Points B, C, and D, reachable from A, will be considered as candidates for the next point to move to.</string>
    <string name="BreadthFirstSearch3">One point is selected from among the candidates. The basis for selection is whichever one was added as a candidate first.</string>
    <string name="BreadthFirstSearch38">The goal has been reached, so the search is ended.</string>
    <string name="BreadthFirstSearch39">As you can see, breadth-first search is unique in how it searches broadly from those points closest to the starting point.</string>
    <string name="BreadthFirstSearch4">"For points that became candidates at the same time, it doesn't matter which one is selected. This time, for convenience, we'll select points from the left side."</string>
    <string name="BreadthFirstSearch40">This concludes the explanation of breadth-first search.</string>
    <string name="BreadthFirstSearch5">"Since they all became candidates at the same time in this instance, we'll select B."</string>
    <string name="BreadthFirstSearch6">We move to the selected point.</string>
    <string name="BreadthFirstSearch7">E and F, reachable from the current point, B, are added as new candidates.</string>
    <string name="BreadthFirstSearch8">"Candidate points are managed under the \"First In First Out\" (FIFO) method, so we're able to use the \"queue\" data structure."</string>
    <string name="BreadthFirstSearch9">\"Queues\" are explained in more detail elsewhere in this app.</string>
    <string name="BubbleSort">冒泡排序</string>
    <string name="BubbleSort0">\"冒泡排序\" 是一种用来对数列进行排序的算法.</string>
    <string name="BubbleSort1">我们首先比较位于数列最右端的两个数字.</string>
    <string name="BubbleSort16">我们已经比较到左边的第一个数和第二个数了.</string>
    <string name="BubbleSort2">"在这个例子里面,我们比较的是7和6这两个数字"</string>
    <string name="BubbleSort20">在一轮这样的比较和交换的操作后,我们已经把数列中最小的数移动到了最左边的位置.</string>
    <string name="BubbleSort21">我们把最左边的数看作是已经排好序的数列...</string>
    <string name="BubbleSort22">然后我们又回到最右边开始新的一轮比较.</string>
    <string name="BubbleSort23">重复这个操作直到所有的数都被排好序.</string>
    <string name="BubbleSort25">到这里,排序已经完成了.</string>
    <string name="BubbleSort26">这就是冒泡排序.</string>
    <string name="BubbleSort3">比较完这两个数字之后,如果我们发现右边的数字比左边的数字小,那么我们就把这两个数字的位置交换.</string>
    <string name="BubbleSort4">6比7小,于是我们交换这两个数字的位置.</string>
    <string name="BubbleSort5">完成两个数的比较和交换之后,我们开始比较右边的第二个数和第三个数.</string>
    <string name="BubbleSort6">我们再次用同样的方式对这两个数进行比较.</string>
    <string name="BubbleSort7">"这个时候, 6比4大,所以它们不需要被交换位置."</string>
    <string name="BubbleSort8">然后我们再向左移一个位置,对右边第三个数和右边第四个数进行比较.</string>
    <string name="BubbleSort9">重复这个比较的操作,直到我们比较到左边的第一个数和第二个数为止.</string>
    <string name="BuyAllAlgorithms">购买所有的算法主题: %@</string>
    <string name="BuyAllAlgorithmsAndroid">购买所有的算法主题:</string>
    <string name="CKC">Shared-Key Cryptosystem</string>
    <string name="CKC0">The \"shared-key cryptosystem\" is an encryption system that uses the same key for encryption and decryption.</string>
    <string name="CKC1">"Let's look at the broader picture of how data is exchanged using the shared-key cryptosystem."</string>
    <string name="CKC10">Party B uses the key to decrypt the ciphertext received from party A.</string>
    <string name="CKC11">Party B has now obtained the original data.</string>
    <string name="CKC12">"If you encrypt the data, there's nothing to worry about even if a malicious third party intercepts it."</string>
    <string name="CKC13">Using the same key for encryption and decryption is a feature of the shared-key cryptosystem.</string>
    <string name="CKC14">Displayed in the diagram are some calculation methods used in the shared-key cryptosystem.</string>
    <string name="CKC15">Today, the method known as \"AES\" is widely used.</string>
    <string name="CKC16">"Next, let's think about some issues with the shared-key cryptosystem."</string>
    <string name="CKC17">"We'll return briefly to the prior situation. Now, party B has just received the ciphertext sent by party A."</string>
    <string name="CKC18">"It's possible that the ciphertext has been intercepted by party X."</string>
    <string name="CKC19">"Now, because party A and party B aren't in direct acquaintance..."</string>
    <string name="CKC2">"Let's say that party A wants to send data to party B over the internet."</string>
    <string name="CKC20">"let's think about what would happen if party B doesn't know the key used for encryption."</string>
    <string name="CKC21">Party A needs to give the key to party B somehow.</string>
    <string name="CKC22">Like they did with the ciphertext, party A sends the key to party B over the internet.</string>
    <string name="CKC23">Party B, using the key received from party A...</string>
    <string name="CKC24">was able to decrypt the ciphertext.</string>
    <string name="CKC25">"However, it's possible that party X intercepts the key as well."</string>
    <string name="CKC26">"If that's the case, party X is also able to use the key and decrypt the ciphertext."</string>
    <string name="CKC27">We can see that there is a problem with how this key is transmitted.</string>
    <string name="CKC28">"So, party A thought about encrypting the key itself so that it won't matter if it's intercepted by party X."</string>
    <string name="CKC29">To a computer, a key is no more than a piece of data.</string>
    <string name="CKC3">The data is delivered to party B after passing through various networks and devices on the internet.</string>
    <string name="CKC30">Therefore...</string>
    <string name="CKC31">we can encrypt it with a new key.</string>
    <string name="CKC32">The ciphertext containing the key...</string>
    <string name="CKC33">is sent to party B.</string>
    <string name="CKC34">Now party B has the encrypted data as well as an encrypted key for decrypting that data.</string>
    <string name="CKC35">There is still a chance that party X will intercept the encrypted key.</string>
    <string name="CKC36">Now all that remains is to transmit the new key used to encrypt the key to party B...</string>
    <string name="CKC37">but how should party A send this new key to party B?</string>
    <string name="CKC38">Without encrypting it, party X could also intercept the new key and be able to use it.</string>
    <string name="CKC39">If we encrypt it, there will be a new key, and the problem repeats itself.</string>
    <string name="CKC4">Thus, if one attempts to send data as-is...</string>
    <string name="CKC40">In summary, the shared-key cryptosystem requires a secure method of transmitting keys.</string>
    <string name="CKC41">This is called the \"key delivery problem\".</string>
    <string name="CKC42">There are two types of solutions to this problem, 1) methods using key exchange protocols and 2) methods using the public-key cryptosystem, each explained in more detail elsewhere in this app.</string>
    <string name="CKC43">This concludes the explanation of the shared-key cryptosystem.</string>
    <string name="CKC5">"it's possible for a malicious third party to intercept the data."</string>
    <string name="CKC6">"For this reason, it's necessary to encrypt data you want to remain private before you send it."</string>
    <string name="CKC7">Using a key...</string>
    <string name="CKC8">the data is encrypted into ciphertext.</string>
    <string name="CKC9">The ciphertext is sent to party B.</string>
    <string name="CannotPayAlert">"Purchases are restricted. Please change your device's settings."</string>
    <string name="CannotRestoreAlert">Purchase records could not be confirmed. Please make sure that you are logged in to the same iTunes account that you used to when you made the purchase.</string>
    <string name="CannotRestoreAlertAndroid">Purchase records could not be confirmed. Please make sure that you are logged in to the same Google Play Store account that you used to when you made the purchase.</string>
    <string name="ChangeConfirmation">Are you sure you want to make these changes?</string>
    <string name="ClusteringSection">Clustering</string>
    <string name="CompressionSection">数据压缩</string>
    <string name="Config">设置</string>
    <string name="DataStructureSection">数据结构</string>
    <string name="DepthFirstSearch">深度优先查找</string>
    <string name="DepthFirstSearch0">\"Depth-first search\" is an algorithm that searches through graphs.</string>
    <string name="DepthFirstSearch1">"We'll begin the search with A as the starting point and G as the goal."</string>
    <string name="DepthFirstSearch11">Among the candidates, E and F were the newest ones added. Between those two, we select E from the left side.</string>
    <string name="DepthFirstSearch12">We move to the selected point.</string>
    <string name="DepthFirstSearch13">K, reachable from the current point E, is added as a new candidate.</string>
    <string name="DepthFirstSearch14">Hereafter, the same operation is repeated until the goal is reached or all of the points have been fully searched.</string>
    <string name="DepthFirstSearch2">Points B, C, and D, reachable from A, will be considered as candidates for the next point to move to.</string>
    <string name="DepthFirstSearch28">The goal has been reached, so the search is ended.</string>
    <string name="DepthFirstSearch29">As you can see, depth-first search is unique in how it searches by digging more deeply into a particular path.</string>
    <string name="DepthFirstSearch3">One point is selected from among the candidates. The basis for selection is whichever one was added as a candidate last.</string>
    <string name="DepthFirstSearch30">This concludes the explanation of depth-first search.</string>
    <string name="DepthFirstSearch4">"For points that became candidates at the same time, it doesn't matter which one is selected. This time, for convenience, we'll select points from the left side."</string>
    <string name="DepthFirstSearch5">"Since they all became candidates at the same time in this instance, we'll select B."</string>
    <string name="DepthFirstSearch6">We move to the selected point.</string>
    <string name="DepthFirstSearch7">E and F, reachable from the current point, B, are added as new candidates.</string>
    <string name="DepthFirstSearch8">"Candidate points are managed under the \"Last In First Out\" (LIFO) method, so we're able to use the \"stack\" data structure."</string>
    <string name="DepthFirstSearch9">\"Stacks\" are explained in more detail elsewhere in this app.</string>
    <string name="DiffieHellman">Diffie-Hellman(迪菲-赫尔曼)密钥交换</string>
    <string name="DiffieHellman0">The \"Diffie-Hellman key exchange\" is a method of securely exchanging keys between 2 parties.</string>
    <string name="DiffieHellman1">"Before using mathematical formulas to explain it, let's start with a more conceptual understanding using a diagram."</string>
    <string name="DiffieHellman10">can in turn be used as an element for synthesizing a new key.</string>
    <string name="DiffieHellman11">In the example in the diagram, by using keys P and P-S, a new key, P-P-S, was synthesized.</string>
    <string name="DiffieHellman12">In other words, any synthesized key can be further combined.</string>
    <string name="DiffieHellman13">"Let's try securely exchanging keys between party A and party B using this combining method."</string>
    <string name="DiffieHellman14">First, party A prepares key P. This key P can be known by anyone without issue.</string>
    <string name="DiffieHellman15">Party A sends key P to party B.</string>
    <string name="DiffieHellman16">Next, party A and party B prepare secret keys SA and SB, respectively.</string>
    <string name="DiffieHellman17">Keys SA and SB need to be managed so that no one else gets their hands on them.</string>
    <string name="DiffieHellman18">Party A synthesizes new key P-SA from key P and secret key SA.</string>
    <string name="DiffieHellman19">Likewise, party B synthesizes new key P-SB from key P and secret key SB.</string>
    <string name="DiffieHellman2">"Let's say there's a special method for combining 2 keys."</string>
    <string name="DiffieHellman20">Party A sends key P-SA to party B.</string>
    <string name="DiffieHellman21">Likewise, party B sends key P-SB to party A.</string>
    <string name="DiffieHellman22">Party A combines secret key SA with key P-SB received from party B to obtain new key P-SA-SB.</string>
    <string name="DiffieHellman23">Likewise, party B combines secret key SB with key P-SA received from party A, and obtains new key P-SA-SB.</string>
    <string name="DiffieHellman24">Thus, both party A and party B were able to obtain key P-SA-SB.</string>
    <string name="DiffieHellman25">This key will be used as an encryption/decryption key.</string>
    <string name="DiffieHellman26">"Let's verify the security of this key exchange method."</string>
    <string name="DiffieHellman27">Because keys P, P-SA, and P-SB are all being sent over the internet...</string>
    <string name="DiffieHellman28">"there's a chance they'll be intercepted by a malicious third party X."</string>
    <string name="DiffieHellman29">"However, party X can't synthesize key P-SA-SB from the keys they obtain."</string>
    <string name="DiffieHellman3">With that method, when key P and key S are combined...</string>
    <string name="DiffieHellman30">"Furthermore, because the keys can't be deconstructed, secret keys SA and SB can't be obtained."</string>
    <string name="DiffieHellman31">"Consequently, because party X can't create key P-SA-SB, this key exchange method is found to be secure."</string>
    <string name="DiffieHellman32">"Next, let's try expressing this key exchange method in mathematical terms."</string>
    <string name="DiffieHellman33">"First, let's explain the \"mod\" operation."</string>
    <string name="DiffieHellman34">The mod operation is an operation that finds the remainder of a division.</string>
    <string name="DiffieHellman35">For A mod B, we get C, the remainder of A divided by B.</string>
    <string name="DiffieHellman36">"Let's show some example operations using concrete numbers."</string>
    <string name="DiffieHellman37">"Now, let's try thinking about the key exchange method in mathematical terms."</string>
    <string name="DiffieHellman38">Key P, which was made at the beginning and can be made public, will be expressed as the 2 numbers P and G in the formula.</string>
    <string name="DiffieHellman39">"P is an extremely large prime number. G will be chosen from among prime number P's so-called generator (or primitive root) numbers."</string>
    <string name="DiffieHellman4">a new key, P-S, is constructed from components of key P and key S.</string>
    <string name="DiffieHellman40">A fixed number of primitive roots exist for all prime numbers P.</string>
    <string name="DiffieHellman41">First, party A will prepare prime number P and primitive root G. These numbers can be known by anyone without issue.</string>
    <string name="DiffieHellman42">Party A sends prime number P and primitive root G to party B.</string>
    <string name="DiffieHellman43">Next, party A and party B prepare secret numbers X and Y, respectively.</string>
    <string name="DiffieHellman44">Furthermore, secret numbers X and Y need to be smaller than prime number P - 2.</string>
    <string name="DiffieHellman45">Party A and party B each perform the calculation of (primitive root G to the power of their secret number) mod (prime number P).</string>
    <string name="DiffieHellman46">This calculation is conceptually like a synthesis.</string>
    <string name="DiffieHellman47">Parties A and B send the results of their calculations to each other.</string>
    <string name="DiffieHellman48">Parties A and B then calculate (the numbers they receive to the power of their secret number) mod (prime number P).</string>
    <string name="DiffieHellman49">These calculations result in the same value.</string>
    <string name="DiffieHellman5">This combining method has 2 special features.</string>
    <string name="DiffieHellman50">Thus, parties A and B were able to share numbers usable as codes.</string>
    <string name="DiffieHellman51">"Let's try verifying the security of this key exchange method."</string>
    <string name="DiffieHellman52">Because the numbers are being sent over the internet...</string>
    <string name="DiffieHellman53">"there's a chance they'll be intercepted by party X."</string>
    <string name="DiffieHellman54">"However, the numbers shared between parties A and B can't be calculated from the numbers obtainable by party X."</string>
    <string name="DiffieHellman55">"Also, secret numbers X and Y can't be solved for."</string>
    <string name="DiffieHellman56">The method of solving for X in (primitive root G to the power of X) mod (prime number P) is called the \"discrete logarithm problem\", and has not yet been discovered.</string>
    <string name="DiffieHellman57">The Diffie-Hellman key exchange can be said to be a key exchange method that utilizes the discrete logarithm problem.</string>
    <string name="DiffieHellman58">This concludes the explanation of the Diffie-Hellman key exchange.</string>
    <string name="DiffieHellman6">The 1st feature is that even if someone has key P and the combined key created from it, P-S...</string>
    <string name="DiffieHellman7">"it's impossible to extract key S."</string>
    <string name="DiffieHellman8">"In other words, even if you're able to synthesize a key, you can't deconstruct it."</string>
    <string name="DiffieHellman9">The 2nd feature is that any key combined from other keys...</string>
    <string name="DiffieHellmanDescription">The \"Diffie-Hellman key exchange\" is a method of securely exchanging keys between 2 parties. You can study this topic after purchasing all of the algorithms.</string>
    <string name="DigitalCertification">数字证书</string>
    <string name="DigitalCertification0">The public-key cryptosystem and the digital signature systems had the problem of not guaranteeing who a public key belongs to.</string>
    <string name="DigitalCertification1">Therefore, when party A was attempting to send the public key to party B...</string>
    <string name="DigitalCertification10">A certification authority has their own public keys (PC) and secret keys (SC) that they prepare themselves.</string>
    <string name="DigitalCertification11">Party A prepares their own personal information, including their public key (PA) and email address...</string>
    <string name="DigitalCertification12">and sends it to a certification authority.</string>
    <string name="DigitalCertification13">"Once confirmation is complete, the certification authority uses their secret key (SC) and creates a digital signature from party A's data."</string>
    <string name="DigitalCertification14">A more detailed explanation of the digital signature system can be found elsewhere in this app.</string>
    <string name="DigitalCertification15">Next, the created digital signature and the data are made into a single file...</string>
    <string name="DigitalCertification16">and sent to party A.</string>
    <string name="DigitalCertification17">"This file becomes party A's digital certificate."</string>
    <string name="DigitalCertification18">In place of a public key, party A sends the digital certificate they received to party B.</string>
    <string name="DigitalCertification19">Party B confirms that the email address in the digital certificate they received belongs to party A.</string>
    <string name="DigitalCertification2">a malicious third party could slip the recipient a different public key without them noticing.</string>
    <string name="DigitalCertification20">"After that, party B acquires the certification authority's public key..."</string>
    <string name="DigitalCertification21">and verifies that the digital signature in the digital certificate is from the certification authority.</string>
    <string name="DigitalCertification22">The digital signature in the digital certificate can only be verified using the public key (PC) from the certification authority.</string>
    <string name="DigitalCertification23">In other words, if the results of the verification are problem-free, then the digital certificate was undoubtedly issued by the certification authority.</string>
    <string name="DigitalCertification24">"Since it has been confirmed that the digital signature belongs to party A and was issued by the certification authority, party A's public key (PA) is extracted from the digital signature."</string>
    <string name="DigitalCertification25">With this, the delivery of a public key from party A to party B is complete.</string>
    <string name="DigitalCertification26">"Let's see if there are any problems with this style of public key delivery."</string>
    <string name="DigitalCertification27">"Let's say a malicious party X, posing as party A, attempts to pass on his own public key."</string>
    <string name="DigitalCertification28">"However, party B has no reason to trust a key that wasn't sent as a digital certificate."</string>
    <string name="DigitalCertification29">So what happens when party X poses at party A and tries to get their own public key registered with the certification authority?</string>
    <string name="DigitalCertification3">By using a \"digital certificate\" system, we can guarantee who the creator of a public key is.</string>
    <string name="DigitalCertification30">"In such a case, party X doesn't have access to party A's email account, so party X can't get a certificate issued."</string>
    <string name="DigitalCertification31">"Party X can only create certificates that use party X's email address. Therefore, they can't obtain party A's certificate."</string>
    <string name="DigitalCertification32">"As you have seen, by using a digital certificate system, it's possible to verify the owner of a public key."</string>
    <string name="DigitalCertification33">"Now, earlier we said that party B received the certification authority's public key..."</string>
    <string name="DigitalCertification34">but this brings up a question.</string>
    <string name="DigitalCertification35">Was the public key (PC) that party B received really created by the certification authority?</string>
    <string name="DigitalCertification36">"Because there's no way of confirming who created the key itself, it might have been created by a party X posing as the certification authority."</string>
    <string name="DigitalCertification37">"In other words, the same problem we've seen with public keys occurs here too."</string>
    <string name="DigitalCertification38">In truth, this public key (PC) of the certification authority...</string>
    <string name="DigitalCertification39">is also delivered as a digital certificate.</string>
    <string name="DigitalCertification4">"Let's take a closer look at how the digital certificate system works."</string>
    <string name="DigitalCertification40">"And the party who \"signed\" the certification authority's digital certificate..."</string>
    <string name="DigitalCertification41">is a higher ranked certification authority.</string>
    <string name="DigitalCertification42">Certification authorities form a tree structure, with the higher ranking authorities creating the digital signatures for the lower ranking ones.</string>
    <string name="DigitalCertification43">To see how this certification authority tree structure functions...</string>
    <string name="DigitalCertification44">"let's say for example we have a certification authority Y that is widely trusted by society."</string>
    <string name="DigitalCertification45">Even if new company G wants to begin service as a certification authority, it has no credibility in society.</string>
    <string name="DigitalCertification46">Therefore, company G has a digital certificate issued by company Y. Of course, company Y will check to make sure that company G can adequately perform the duties of a certification authority.</string>
    <string name="DigitalCertification48">As a result, company G can advertise themselves as a company that has earned the trust of company Y.</string>
    <string name="DigitalCertification49">By doing this, larger organizations secure the trust of smaller organizations, forming an organized tree structure.</string>
    <string name="DigitalCertification5">"Let's say that party A, in possession of both the public key (PA) and the secret key (SA)..."</string>
    <string name="DigitalCertification50">"So, just who's at the top of the certification authority tree?"</string>
    <string name="DigitalCertification51">A certification authority that holds the top position is called a \"root certification authority (root CA)\", and certifies its own validity.</string>
    <string name="DigitalCertification52">Furthermore, certificates that a root certification authority certifies itself are called \"root certificates\".</string>
    <string name="DigitalCertification53">If a root certification authority is not itself a trusted organization, it will not be used.</string>
    <string name="DigitalCertification54">Therefore, a sizable number of them are organizations that already have societal credibility, such as large companies and government agencies.</string>
    <string name="DigitalCertification55">"Now, we've taken a look at the transfer of public keys between individuals..."</string>
    <string name="DigitalCertification56">but digital certificates are also used when communicating with a website.</string>
    <string name="DigitalCertification57">By obtaining a certificate that includes a public key from a website, we can be sure that the site is not being spoofed by a third party.</string>
    <string name="DigitalCertification58">This certificate is called a \"server certificate\", and is also issued by a certification authority.</string>
    <string name="DigitalCertification59">In the case of an individual, the certificate is bound to an email address...</string>
    <string name="DigitalCertification6">is ready to send the public key (PA) to party B.</string>
    <string name="DigitalCertification60">"but in the server certificate's case, it's bound to a domain."</string>
    <string name="DigitalCertification61">A server certificate guarantees that the public key was issued by the organization that manages the domain that the certificate is bound to.</string>
    <string name="DigitalCertification62">"In other words, it can be confirmed that the organization managing the website's domain and the organization managing the server that stores the website's content are one in the same."</string>
    <string name="DigitalCertification63">In this way, digital certificates are a societal system of guaranteeing the creators of public keys via certification authorities.</string>
    <string name="DigitalCertification64">This concludes the explanation of digital certificates.</string>
    <string name="DigitalCertification7">First, party A needs to request for a certification authority to issue a certificate showing that they are the owner of the public key (PA).</string>
    <string name="DigitalCertification8">A certification authority is an organization that manages digital certificates. Basically, anyone can become such an organization, and they exist in great numbers.</string>
    <string name="DigitalCertification9">"Therefore, it's safest to utilize trustworthy organizations like the government or large companies that undergo audits."</string>
    <string name="DigitalCertificationDescription">\"Digital certificates\" are a system of guaranteeing the creator of a public key. You can study this topic after purchasing all of the algorithms.</string>
    <string name="DigitalSignature">数字签名</string>
    <string name="DigitalSignature0">A \"digital signature\" system guarantees non-repudiation...</string>
    <string name="DigitalSignature1">in addition to authentication and falsification detection, the two functions implemented by message authentication codes.</string>
    <string name="DigitalSignature10">For example, after party A sends the message to party B, party B can then claim themselves to be the creator of the message.</string>
    <string name="DigitalSignature100">"Strictly speaking, there are also instances where signature creation's calculation methods are different than encryption's."</string>
    <string name="DigitalSignature101">"However, they share the characteristic of using shared keys for signature creation and public keys for signature verification, so we're explaining it that way for convenience's sake."</string>
    <string name="DigitalSignature11">"Also, because they're using shared keys, a different key will need to be prepared if party A decides to send the message to someone other than party B"</string>
    <string name="DigitalSignature12">On the other hand, instead of using MACs, the digital signature system uses data that only the sender can create as its basis for identification. This data is called a \"digital signature\".</string>
    <string name="DigitalSignature13">"Let's take a look at an outline of the process."</string>
    <string name="DigitalSignature14">The \"Sig.\" in the image is the digital signature, and can only be created by party A.</string>
    <string name="DigitalSignature15">"Therefore, when a message with party A's digital signature assigned to it is received, it's guaranteed that the sender was indeed party A."</string>
    <string name="DigitalSignature16">"The recipient of the message, party B, is able to confirm that the digital signature is party A's, but they can't create the same digital signature themselves."</string>
    <string name="DigitalSignature17">In contrast to message authentication codes, because a shared key is not used, party A can send their message to multiple people using the same digital signature.</string>
    <string name="DigitalSignature2">"Let's review message authentication codes."</string>
    <string name="DigitalSignature20">"Let's take a closer look at how a digital signature is created."</string>
    <string name="DigitalSignature21">While the key used in creating MACs in message authentication codes was a shared one...</string>
    <string name="DigitalSignature22">when creating digital signatures, we apply the \"public-key cryptosystem\" process.</string>
    <string name="DigitalSignature23">A more detailed explanation of the \"public-key cryptosystem\" can be found elsewhere in this app. Here we will give a rough review of how it works.</string>
    <string name="DigitalSignature24">Party A has encrypted the data and is ready to send it to party B.</string>
    <string name="DigitalSignature25">First, the person on the receiving end, party B, prepares a public key (P) and a secret key (S).</string>
    <string name="DigitalSignature26">Party B passes the public key to party A.</string>
    <string name="DigitalSignature27">Party A uses the public key to encrypt the data.</string>
    <string name="DigitalSignature28">Then they send the ciphertext to party B.</string>
    <string name="DigitalSignature29">Party B decrypts the ciphertext they received into its original data using the secret key, completing the exchange.</string>
    <string name="DigitalSignature3">The message authentication code system assigns a MAC to a message in order to identify the sender of the message as the owner of the encryption key.</string>
    <string name="DigitalSignature30">So, with the public-key cryptosystem, a public key was used for encryption and a secret key was used for decryption.</string>
    <string name="DigitalSignature31">Therefore, anyone can encrypt the data using a public key...</string>
    <string name="DigitalSignature32">"but because only party B possesses the secret key, it's guaranteed that only they can perform the decryption."</string>
    <string name="DigitalSignature33">Now, what happens if we reverse the process, using the secret key for encryption and the public key for decryption?</string>
    <string name="DigitalSignature34">In this case, as party A has the secret key, only they can encrypt the data, but the ciphertext created can be decrypted by anyone who possesses the public key.</string>
    <string name="DigitalSignature35">This is absolutely meaningless as a form of encryption, but looking at it a different way, you can see that the creator of the ciphertext is guaranteed to be party A, the one who has the secret key.</string>
    <string name="DigitalSignature36">In a digital signature, this ciphertext that only party A can create is used as the signature.</string>
    <string name="DigitalSignature37">"Let's take a look at how an exchange works with a message that has used a digital signature."</string>
    <string name="DigitalSignature38">First, party A prepares the message they want to send, as well as the secret and public keys.</string>
    <string name="DigitalSignature39">The fact that the sender of the message prepares the secret and public keys is where it differs from the public-key cryptosystem.</string>
    <string name="DigitalSignature4">"Here, for convenience, let's send a message without encrypting it."</string>
    <string name="DigitalSignature40">Party A passes the public key to party B.</string>
    <string name="DigitalSignature41">Then they encrypt the message using the secret key.</string>
    <string name="DigitalSignature42">The ciphertext will serve as the signature, and be marked as \"Sig.\" on the diagram from here on out.</string>
    <string name="DigitalSignature43">Party A sends the message and the signature to party B.</string>
    <string name="DigitalSignature44">Party B decrypts the ciphertext using the public key.</string>
    <string name="DigitalSignature45">"It's confirmed that the decrypted message matches the received message, completing the exchange."</string>
    <string name="DigitalSignature46">"The ciphertext, which can be decrypted with party A's public key, can only be created by party A themselves."</string>
    <string name="DigitalSignature47">Therefore, we can confirm that party A is the one who sent the message and that the message was not falsified.</string>
    <string name="DigitalSignature48">"Also, because party A's signature can't be created by party B, who only has the public key, the role of preventing repudiation is also fulfilled."</string>
    <string name="DigitalSignature49">However, the public-key cryptosystem tends to take time for encryption and decryption.</string>
    <string name="DigitalSignature5">Party A sends the message and the MAC, as well as the key used to create the MAC, to party B.</string>
    <string name="DigitalSignature50">So, rather than encrypting the message directly...</string>
    <string name="DigitalSignature51">"to shorten the calculation time, first, the message's hash value is determined..."</string>
    <string name="DigitalSignature52">then that hash value is encrypted and used as the signature.</string>
    <string name="DigitalSignature53">A more detailed explanation of hashing can be found in the \"Hash Function\" entry in this app.</string>
    <string name="DigitalSignature54">The message and the signature are sent to party B.</string>
    <string name="DigitalSignature55">In the same manner, party B calculates the hash value of the received message.</string>
    <string name="DigitalSignature56">Next, the received signature is decrypted using the public key, and from that a hash value is calculated.</string>
    <string name="DigitalSignature57">If it can be confirmed that the two hash values match, the exchange using a digital signature is complete.</string>
    <string name="DigitalSignature58">Digital signatures provide the functions of authentication, falsification detection, and repudiation prevention, but there is one problem.</string>
    <string name="DigitalSignature59">Party B, by making an exchange with the use of a digital signature, believes that party A was the sender...</string>
    <string name="DigitalSignature6">Party B recreates the MAC using the received message and key and confirms that it matches the MAC they received.</string>
    <string name="DigitalSignature60">"but in actuality, we can't say there's zero chance that some malicious party X didn't carry out the exchange posing as party A."</string>
    <string name="DigitalSignature61">"The fundamental cause of this problem lies in the fact that in the public-key cryptosystem, we don't know who the public key belongs to."</string>
    <string name="DigitalSignature62">"There isn't a single piece of information included with the public key to indicate who created it."</string>
    <string name="DigitalSignature63">"Therefore, there's the possibility that the public key was created by someone posing as party A..."</string>
    <string name="DigitalSignature64">as well as the possibility that party A really did create the public key, but neither is certain.</string>
    <string name="DigitalSignature66">This problem can be solved with the \"digital certificate\" system.</string>
    <string name="DigitalSignature67">In a digital certificate, information about the creator of a public key is part of the key, and is handled as a single certificate.</string>
    <string name="DigitalSignature68">A more detailed explanation of \"digital certificates\" can be found elsewhere in this app.</string>
    <string name="DigitalSignature69">This concludes the explanation of digital signatures.</string>
    <string name="DigitalSignature8">From this, it can be verified that party A was the sender and the message was not falsified.</string>
    <string name="DigitalSignature9">"However, because message authentication codes use a shared key, it's still possible for anyone else in possession of the key to pose as the sender of the message."</string>
    <string name="DigitalSignatureDescription">\"Digital signatures\" are a system of solving the issues of spoofing, falsification, and non-repudiation. You can study this topic after purchasing all of the algorithms.</string>
    <string name="Dijkstra">"Dijkstra(迪杰斯特拉)算法"</string>
    <string name="Dijkstra0">"\"Dijkstra's algorithm\" is an algorithm used to find the shortest path between points on a graph. It is a more efficient method than the Bellman-Ford algorithm."</string>
    <string name="Dijkstra1">"To start, each point's initial cost value is set. The starting point is set to 0, and all others are set to infinity."</string>
    <string name="Dijkstra10">Taking the path determined to be the shortest, we move to point B.</string>
    <string name="Dijkstra100">The reason for this is that choosing to follow another path requires that we pass through point C, resulting in a higher cost than our current path.</string>
    <string name="Dijkstra101">Path A-B-D was the result of choosing the candidate points with the lowest cost. Thus, we know that passing through any other point to get to D is certain to have a higher cost.</string>
    <string name="Dijkstra102">In this case, points B and C become candidates.</string>
    <string name="Dijkstra11">"Points accessible from the current point are added as candidates. In this case, they're points C, D and E."</string>
    <string name="Dijkstra12">Using the same method as before, we calculate the cost of each candidate.</string>
    <string name="Dijkstra13">The total cost of moving to point C from B is 2 + 6 = 8, which is greater than its current value of 5, so no update is made.</string>
    <string name="Dijkstra14">The costs of the remaining points, D and E, were updated.</string>
    <string name="Dijkstra15">"From the candidate points, we choose the one with the lowest cost. In this case it's D."</string>
    <string name="Dijkstra16">"At this point, we've determined that the chosen path A-B-D is the shortest path from the starting point to D."</string>
    <string name="Dijkstra17">"In this way, Dijkstra's algorithm searches through a graph determining the shortest path to each point, one path at a time."</string>
    <string name="Dijkstra18">The same operation is repeated until reaching the last point, G.</string>
    <string name="Dijkstra2">We start from the first point.</string>
    <string name="Dijkstra3">Starting at the present location, we search for unexplored points. Once found, these points become candidates for moving to next.</string>
    <string name="Dijkstra35">"We've reached the last point, G, so the search is finished."</string>
    <string name="Dijkstra36">In the end, the trees highlighted in orange, called \"shortest-path trees\", show us the shortest path to each point on the graph.</string>
    <string name="Dijkstra37">The more thickly highlighted one is the shortest path to the last point, G.</string>
    <string name="Dijkstra38">"As you can see, compared to the Bellman-Ford algorithm that repeatedly calculates and updates the cost for all edges, Dijkstra's algorithm efficiently searches for the shortest path by devising which points to choose next."</string>
    <string name="Dijkstra39">Like the Bellman-Ford algorithm, even if there are one-way edges or edges with different costs for coming and going...</string>
    <string name="Dijkstra4">"The cost of each path is calculated. The method of calculation is the current point's cost + the cost of moving to a candidate point."</string>
    <string name="Dijkstra40">"Dijkstra's algorithm can find the shortest path."</string>
    <string name="Dijkstra41">Graphs where the direction of the edges is fixed, as in the diagram, are called \"directed graphs\", and graphs where the direction of the edges is not fixed are called \"undirected graphs\".</string>
    <string name="Dijkstra42">"There are times when Dijkstra's algorithm cannot correctly find the shortest path if a graph contains a path with a \"negative cost.\" It differs from the Bellman-Ford algorithm in this respect."</string>
    <string name="Dijkstra43">In the graph, A-C-B-G is the shortest path and includes traversing the C-B path, which has a negative cost.</string>
    <string name="Dijkstra44">"As a test, let's work it out using Dijkstra's algorithm."</string>
    <string name="Dijkstra45">"Points B and C, which are reachable from starting point A and haven't been fully explored, have costs of 2 and 4, respectively."</string>
    <string name="Dijkstra46">"At this point, Dijkstra's algorithm determines that the shortest path from starting point A to point B is the A-B path."</string>
    <string name="Dijkstra47">The reason for that is using any other path requires passing through point C, and the A-C path has a higher cost than the A-B path.</string>
    <string name="Dijkstra48">As you already know, it is assumed that all edges have a cost greater than 0, in other words, that no negative costs exist on the graph.</string>
    <string name="Dijkstra49">The algorithm concluded that the shortest path from the starting point A to the end point G is the A-B-C path, having a cost of 3. As stated before, this is an error.</string>
    <string name="Dijkstra5">"For example, in the case of moving to B, the starting point's cost is 0, so the cost is 0 + 2 = 2. Similarly, the cost of moving to C would be 0 + 5 = 5."</string>
    <string name="Dijkstra52">Furthermore, with a graph like this one...</string>
    <string name="Dijkstra53">that contains a \"negative cycle\" that results in a negative cost when taking certain paths...</string>
    <string name="Dijkstra54">"with Dijkstra's algorithm, an erroneous solution will be arrived at regardless of whether a shortest path even exists."</string>
    <string name="Dijkstra55">"Therefore, Dijkstra's algorithm cannot be used with a graph that contains negative cost."</string>
    <string name="Dijkstra56">"Conversely, for graphs that don't contain negative cost, it can be said that Dijkstra's algorithm can find the shortest path with fewer calculations than the Bellman-Ford algorithm."</string>
    <string name="Dijkstra57">"This concludes the explanation of Dijkstra's algorithm."</string>
    <string name="Dijkstra6">"If the calculated cost is less than the current value, the point's cost is updated to the new value."</string>
    <string name="Dijkstra7">Since the current costs of B and C are infinity, the calculated results are less, so B and C are updated to the new cost values.</string>
    <string name="Dijkstra8">"From the candidate points, we choose the one with the lowest cost. In this case it's B."</string>
    <string name="Dijkstra9">"At this point, we've determined that the chosen path A-B is the shortest path from the starting point to B."</string>
    <string name="DijkstraDescription">"\"Dijkstra's algorithm\" is an algorithm used to efficiently determine shortest paths. You can study this topic after purchasing all of the algorithms."</string>
    <string name="Euclidean">Euclidian(欧几里德)算法</string>
    <string name="Euclidean0">The \"Euclidian algorithm\" is an algorithm that finds the greatest common divisor of 2 numbers.</string>
    <string name="Euclidean1">"Discovered by Euclid in the mid-4th century BC, it's referred to as the world's oldest algorithm."</string>
    <string name="Euclidean10">For A mod B, we get C, the remainder of A divided by B.</string>
    <string name="Euclidean11">"Let's show some example operations using concrete numbers."</string>
    <string name="Euclidean12">"Now, let's take a look at the Euclidian algorithm in action."</string>
    <string name="Euclidean13">First, we find the remainder of the larger number divided by the smaller number.</string>
    <string name="Euclidean14">"In other words, we'll carry out a mod operation with the larger and smaller numbers."</string>
    <string name="Euclidean15">The result of the division found 417 to be the remainder.</string>
    <string name="Euclidean16">This time, we carry out a mod operation with the previous divisor, 695, and the previous remainder, 417.</string>
    <string name="Euclidean17">We got 278.</string>
    <string name="Euclidean18">We repeat the same operation, carrying out a mod operation with 417 and 278.</string>
    <string name="Euclidean19">We got 139.</string>
    <string name="Euclidean2">"As an example, let's consider the largest common divisor of 1112 and 695."</string>
    <string name="Euclidean20">We carry out a mod operation with 278 and 139.</string>
    <string name="Euclidean21">We got 0.</string>
    <string name="Euclidean22">In other words, 278 is divisible by 139.</string>
    <string name="Euclidean23">When the remainder is 0, the divisor of the last operation, 139, is found to be the greatest common divisor of 1112 and 695.</string>
    <string name="Euclidean24">"How is the Euclidian algorithm able to find the greatest common divisor? Let's consider that question using the diagram."</string>
    <string name="Euclidean25">"We'll try expressing 1112 and 695 in terms of bar length."</string>
    <string name="Euclidean26">"We'll add segments in increments of n, the greatest common divisor."</string>
    <string name="Euclidean27">"It's been determined that 139 is the greatest common divisor, so for convenience, 1112 was given 8 segments, and 695 was given 5 segments."</string>
    <string name="Euclidean28">"In actuality, it isn't known how many segments are on each bar."</string>
    <string name="Euclidean29">However, we do know that both 1112 and 695 are multiples of a greatest common divisor, n.</string>
    <string name="Euclidean3">With the usual method, we factorize the 2 numbers into prime numbers...</string>
    <string name="Euclidean30">"Here, like in the earlier operation, we'll find the remainder of the larger number divided by the smaller number."</string>
    <string name="Euclidean31">We got 417. From the diagram, we can see that 417 is a number also neatly divided into segments of width n.</string>
    <string name="Euclidean32">"We'll repeat the mod operation like we did earlier."</string>
    <string name="Euclidean35">When 695 is divided by 417, we get a remainder of 278.</string>
    <string name="Euclidean36">This remainder of 278 is also an integral multiple of n, in other words, it has the same greatest common divisor.</string>
    <string name="Euclidean37">We repeat the division again.</string>
    <string name="Euclidean38">Because 278 is divisible by 139, the remainder is 0.</string>
    <string name="Euclidean39">It is here that we learn that the greatest common divisor, n, is 139.</string>
    <string name="Euclidean4">and find the greatest common divisor (GCD) from the prime numbers they share.</string>
    <string name="Euclidean40">In this way, the Euclidian algorithm is able to find the greatest common divisor by simply repeating divisions.</string>
    <string name="Euclidean41">A big advantage is that even if the 2 target numbers are huge, the algorithm is able to find the greatest common divisor with a standard procedure.</string>
    <string name="Euclidean42">This concludes the explanation of the Euclidian algorithm.</string>
    <string name="Euclidean5">Now we know that the greatest common divisor for 1112 and 695 is 139.</string>
    <string name="Euclidean6">However, with this method, the larger the 2 numbers get, the more difficult prime factorization becomes.</string>
    <string name="Euclidean7">With the Euclidian algorithm, we can find greatest common divisors more efficiently.</string>
    <string name="Euclidean8">"Before we enter an explanation of the Euclidian algorithm, let's explain the mod operation."</string>
    <string name="Euclidean9">The mod operation is an operation that finds the remainder of a division.</string>
    <string name="ExperimentalModeTitle">模拟</string>
    <string name="GetItemInfoFailed">Getting item information has failed. Please confirm a network connection.</string>
    <string name="GraphSearchSection">图搜索</string>
    <string name="Hanoi">汉诺塔问题</string>
    <string name="Hanoi0">The \"Tower of Hanoi\" is a disk-moving puzzle.</string>
    <string name="Hanoi1">The diagram shows 3 stakes, A, B, and C, with two disks on stake A.</string>
    <string name="Hanoi101">"Let's look at an example of actually moving the disks based on the above conditions."</string>
    <string name="Hanoi102">Then, using the same principles as before, we move the disks on stake B to stake C.</string>
    <string name="Hanoi15">The smaller disk is on top, so we can move it to stake B.</string>
    <string name="Hanoi16">We move the bigger disk to stake C.</string>
    <string name="Hanoi17">Moving the smaller disk to stake C, we finish our moves. We were able to confirm that reaching the goal is possible when there are 2 disks.</string>
    <string name="Hanoi18">What about when there are 3 disks?</string>
    <string name="Hanoi19">"Let's ignore the biggest disk and think about how to move the remaining disks to stake B."</string>
    <string name="Hanoi2">The goal is to move the disks onto stake C while keeping the disks in the same order as stake A.</string>
    <string name="Hanoi20">"If we move the remaining disks in the same general way as before when there were only 2 disks, we're able to move them to stake B."</string>
    <string name="Hanoi21">We move the biggest disk onto stake C.</string>
    <string name="Hanoi22">Our moves are finished. We were able to confirm that reaching the goal is also possible when there are 3 disks.</string>
    <string name="Hanoi23">"Actually, it's possible for all disks to reach the goal in this game no matter how many disks there are."</string>
    <string name="Hanoi24">"Let's try proving this using mathematical induction."</string>
    <string name="Hanoi25">We were able to reach the goal when there was 1 disk.</string>
    <string name="Hanoi27">"Let's assume that we can reach the goal when there are n disks."</string>
    <string name="Hanoi29">"Let's think about moving n + 1 disks."</string>
    <string name="Hanoi30">"We'll ignore the biggest disk."</string>
    <string name="Hanoi31">"Based on our assumption that we're able to move n disks, we move n disks onto stake B."</string>
    <string name="Hanoi32">We move the biggest disk onto stake C.</string>
    <string name="Hanoi33">We move the n disks on stake B to stake C. Our moves are now finished.</string>
    <string name="Hanoi34">Using mathematical induction, we proved that the goal can be reached with any number of disks.</string>
    <string name="Hanoi35">"Let's try thinking about the solution to the Tower of Hanoi."</string>
    <string name="Hanoi36">When solving the Tower of Hanoi with n disks, you can use the solution from the Tower of Hanoi with n - 1 disks.</string>
    <string name="Hanoi37">To solve the Tower of Hanoi with n - 1 disks, you can use the solution from the Tower of Hanoi with n - 2 disks, and so on until finally there is just one disk, bringing you to the solution recursively.</string>
    <string name="Hanoi38">This recursive mode of thinking is used in many algorithms, and such algorithms are called \"recursive algorithms\".</string>
    <string name="Hanoi39">This concludes the explanation of the Tower of Hanoi.</string>
    <string name="Hanoi4">There are two conditions for moving disks. The first condition is that you can only move one disk at a time.</string>
    <string name="Hanoi5">Moving 1 disk like this is no problem...</string>
    <string name="Hanoi6">"but you can't move 2 disks at the same time like in the diagram."</string>
    <string name="Hanoi9">"The 2nd condition is that you can't set a bigger disk on top of a smaller disk."</string>
    <string name="Hash">哈希表</string>
    <string name="Hash0">\"Hash tables\" are one type of data structure.</string>
    <string name="Hash1">They are good at storing data in sets made up of \"keys\" and \"values\".</string>
    <string name="Hash10">"Box 2 wasn't Ally, either."</string>
    <string name="Hash11">"Box 3 wasn't Ally, either."</string>
    <string name="Hash12">The key for the data stored in box 4 matched Ally.</string>
    <string name="Hash13">"By extracting its corresponding value, we learn that Ally's sex is female (F)."</string>
    <string name="Hash14">In this way, the linear search operation carries a cost proportional the size of the data.</string>
    <string name="Hash15">"It takes time to search through data when it's stored in an array, making it an unsuitable choice."</string>
    <string name="Hash16">A hash table solves this problem.</string>
    <string name="Hash17">"We'll prepare an array to store some data. For convenience, we'll have 5 boxes in the array."</string>
    <string name="Hash18">"Now let's store some data."</string>
    <string name="Hash19">When storing the data of \"Joe\"...</string>
    <string name="Hash2">In this case, a name is the key, and a sex is the value.</string>
    <string name="Hash20">we calculate a hash value for the key using the hash function. The result obtained in this case is 4928.</string>
    <string name="Hash21">"A more detailed explanation of the \"hash function\" can be found elsewhere in this app, but it's a function that converts data into a value of fixed length."</string>
    <string name="Hash22">The hash value sought is divided by the number of boxes in the array, 5, to find the remainder.</string>
    <string name="Hash23">The operation that finds the remainder of a division is called the \"mod\" operation.</string>
    <string name="Hash24">The mod operation resulted in a value of 3.</string>
    <string name="Hash25">The data of \"Joe\" is stored in box 3 of the array to match the result.</string>
    <string name="Hash26">This operation will be repeated to store the other data.</string>
    <string name="Hash27">When storing the data of \"Sue\"...</string>
    <string name="Hash28">"we find the key's hash value, and perform a mod operation on it using the number of boxes in the array, 5. The result was 1."</string>
    <string name="Hash29">The data of \"Sue\" is stored in box 1 of the array.</string>
    <string name="Hash3">"As an example, let's imagine the data in the diagram stored as an array."</string>
    <string name="Hash30">When storing the data of \"Dan\"...</string>
    <string name="Hash31">"we find the key's hash value, and perform a mod operation on it using the number of boxes in the array, 5. The result was 4."</string>
    <string name="Hash32">The data of \"Dan\" is stored in box 4 of the array.</string>
    <string name="Hash33">When storing the data of \"Nell\"...</string>
    <string name="Hash34">"we find the key's hash value, and perform a mod operation on it using the number of boxes in the array, 5. The result was 1."</string>
    <string name="Hash35">When we try to store the data of \"Nell\" in box 1 of the array...</string>
    <string name="Hash36">the data of \"Sue\" was already stored there. When something like this happens...</string>
    <string name="Hash37">it gets connected to the existing data as a list.</string>
    <string name="Hash38">There are several types of hash table structures, but the method that uses lists is called the \"chain method\".</string>
    <string name="Hash39">When storing the data of \"Ally\"...</string>
    <string name="Hash4">We prepared 6 boxes for the array and stored data in them.</string>
    <string name="Hash40">"we find the key's hash value, and perform a mod operation on it using the number of boxes in the array, 5. The result was 3."</string>
    <string name="Hash41">Because the data of \"Joe\" is in box 3 of the array, the data of \"Ally\" gets connected as a list.</string>
    <string name="Hash42">When storing the data of \"Bob\"...</string>
    <string name="Hash43">"we find the key's hash value, and perform a mod operation on it using the number of boxes in the array, 5. The result was 3."</string>
    <string name="Hash44">Because the \"Joe\" and \"Ally\" data is in box 3 of the array, the data of \"Bob\" will be connected as a list.</string>
    <string name="Hash45">All data is finished being stored, and the hash table is complete.</string>
    <string name="Hash46">"Let's imagine looking up Dan's sex."</string>
    <string name="Hash47">In order to find out what box of the array Dan is in...</string>
    <string name="Hash48">"we find the key's hash value, and perform a mod operation on it using the number of boxes in the array, 5. The result was 4."</string>
    <string name="Hash49">The key for the data stored in box 4 of the array matched \"Dan\".</string>
    <string name="Hash5">"Now let's imagine looking up Ally's sex."</string>
    <string name="Hash50">"By extracting its corresponding value, we learn that Dan's sex is male (M)."</string>
    <string name="Hash51">"So what happens when we look up Ally's sex?"</string>
    <string name="Hash52">In order to find out what box of the array Ally is in...</string>
    <string name="Hash53">"we find the key's hash value, and perform a mod operation on it using the number of boxes in the array, 5. The result was 3."</string>
    <string name="Hash54">The key for the data stored in box 3 of the array was \"Joe\", not \"Ally\".</string>
    <string name="Hash55">So a linear search is performed on the list starting with the data \"Joe\".</string>
    <string name="Hash56">Data with the key \"Ally\" was found.</string>
    <string name="Hash57">"By extracting its corresponding value, we learn that Ally's sex is female (F)."</string>
    <string name="Hash58">As you can see, by using the hash function, hash tables are able to quickly access data within an array.</string>
    <string name="Hash59">When hash values overlap, lists are used, making it possible to flexibly handle an uncertain amount of data.</string>
    <string name="Hash6">"We don't know what number Ally's box is in the array."</string>
    <string name="Hash60">When the size of an array used by a hash table is too small, the overlaps increase, making linear searches more prevalent.</string>
    <string name="Hash61">Conversely, if the array size is too large, there will be many boxes with no data stored in them, wasting memory, so discretion is needed.</string>
    <string name="Hash62">Hash tables, with their flexible data storage and fast lookup, are used in the associative arrays of programming languages.</string>
    <string name="Hash63">This concludes the explanation of hash tables.</string>
    <string name="Hash7">Thus, we need to search in order from the beginning. This operation is called a \"linear search\".</string>
    <string name="Hash8">"The key for the data stored in box 0 was Joe, which isn't Ally."</string>
    <string name="Hash9">"Box 1 wasn't Ally, either."</string>
    <string name="HashFunction">Hash Functions</string>
    <string name="HashFunction0">"A \"hash function\" is a function that converts the data it's given into an irregular value of fixed length."</string>
    <string name="HashFunction1">A hash function might be easier to understand if we imagine it as a blender.</string>
    <string name="HashFunction10">"Let's look at some features of hash functions from this premise."</string>
    <string name="HashFunction11">Their 1st characteristic is that the data values they output are of fixed length.</string>
    <string name="HashFunction12">"The length of their output data varies according to the hash function. In the case of SHA-1, for example, it's fixed at 20 bytes."</string>
    <string name="HashFunction13">"Even when extremely large amounts of data are input, the output hash value data doesn't vary in length."</string>
    <string name="HashFunction16">Likewise, no matter how small the input, the length of the hash value data is the same.</string>
    <string name="HashFunction19">A 2nd characteristic is that if given the same input, they will invariably produce the same output.</string>
    <string name="HashFunction2">When we input data into a hash function...</string>
    <string name="HashFunction25">A 3rd characteristic is that if similar data is input, even if different by only 1 bit, their output greatly differs.</string>
    <string name="HashFunction3">it outputs an irregular value.</string>
    <string name="HashFunction31">"It isn't the case that if similar data is input, the hash values will be similar, too."</string>
    <string name="HashFunction32">A 4th characteristic is that even if completely different data is input, it does happen that identical hash values are produced, low as the chances may be.</string>
    <string name="HashFunction38">This is called a \"hash collision\".</string>
    <string name="HashFunction39">A 5th characteristic is that converting hash values back into their original data is, in reality, impossible.</string>
    <string name="HashFunction4">"If we imagine a hash function as a machine that blends up data, it's easier to understand."</string>
    <string name="HashFunction41">The flow of input and output is one-way, which is a big difference from \"encryption\".</string>
    <string name="HashFunction43">One final characteristic that can be given is that their calculations are relatively simple.</string>
    <string name="HashFunction46">There are a number of hash function algorithms, but currently it is most common to use \"SHA-2\".</string>
    <string name="HashFunction47">Hash functions can be said to output a summary of the data input, and are used in many situations.</string>
    <string name="HashFunction48">Examples of hash function usage are explained in detail in the \"Message Authentication Codes\" and \"Hash Tables\" entries of this app.</string>
    <string name="HashFunction49">This concludes the explanation of hash functions.</string>
    <string name="HashFunction5">The irregular output from a hash is called a \"hash value\".</string>
    <string name="HashFunction6">Hash values are numbers, but are often written in hexadecimal.</string>
    <string name="HashFunction7">Computers manage all data in binary, which uses 0s and 1s.</string>
    <string name="HashFunction8">Hash values are also data, and are managed in binary.</string>
    <string name="HashFunction9">What a hash function is actually doing is performing some value calculations inside the computer.</string>
    <string name="Heap">堆</string>
    <string name="Heap0">\"Heaps\" are one type of tree data structure, and are used when implementing a \"priority queue\".</string>
    <string name="Heap1">A priority queue is one type of data structure.</string>
    <string name="Heap10">Since the parent (6) is greater than the child (5), the two numbers swap.</string>
    <string name="Heap11">This operation repeats until no additional swaps occur.</string>
    <string name="Heap12">The parent (1) is less than the child (5), so since the parent is smaller, no swap occurs.</string>
    <string name="Heap13">The addition of a number to the heap is now complete.</string>
    <string name="Heap14">When extracting a number from a heap, the number on the top is removed.</string>
    <string name="Heap15">In a heap, the smallest value is held in the top location.</string>
    <string name="Heap16">"Because the top number was removed, the heap's structure needs to be reorganized."</string>
    <string name="Heap17">The number at the end of the line moves to the top.</string>
    <string name="Heap18">When one of the child numbers is less than the parent, the lowest of the adjacent child numbers swap with the parent.</string>
    <string name="Heap19">The parent (6) was greater than the child to the right (5) which was in turn greater than the child to the left (3), so the left child and parent swapped.</string>
    <string name="Heap2">In a priority queue, data can be added in any order.</string>
    <string name="Heap20">This operation repeats until no additional swaps occur.</string>
    <string name="Heap22">The right child (8) was greater than the parent (6) which was in turn greater than the child to the left (4), so the left child and parent swapped.</string>
    <string name="Heap23">The extraction of a number from the heap is now complete.</string>
    <string name="Heap24">In this way, heaps can be used to quickly extract the smallest data.</string>
    <string name="Heap25">However, extraction of data in the middle of the tree cannot be performed.</string>
    <string name="Heap26">"Heaps are used in things like priority queues and Dijkstra's algorithm."</string>
    <string name="Heap27">This concludes the explanation of heaps.</string>
    <string name="Heap3">Conversely, when extracting data, the smallest values are chosen first.</string>
    <string name="Heap4">Being able to freely add data and then extract the smallest values first defines a priority queue.</string>
    <string name="Heap5">"Moving on, let's look at a heap's structure."</string>
    <string name="Heap6">As a rule of heaps, a child number is always greater than its parent number.</string>
    <string name="Heap7">"Let's try adding a number to the heap."</string>
    <string name="Heap8">"The number that's added is first placed onto the end of the line."</string>
    <string name="Heap9">If the parent number happens to be greater, the child and parent swap.</string>
    <string name="HeapDescription">\"Heaps\" are data structures used to quickly extract lowest values. You can study this topic after purchasing all of the algorithms.</string>
    <string name="HeapSort">堆排序</string>
    <string name="HeapSort0">\"Heap sort\" is one algorithm used to sort a sequence of numbers, and features the use of the heap data structure.</string>
    <string name="HeapSort1">To begin, all of the numbers are stored in a heap. These heaps are constructed so that numbers are in descending order. A more detailed explanation of heaps can be found in the \"Heaps\" entry of this app.</string>
    <string name="HeapSort10">To give a more concrete example, the elements of the heap (nodes) and the array...</string>
    <string name="HeapSort105">"Furthermore, while there are more optimized methods for constructing heaps, this time we've chosen an easy-to-understand one."</string>
    <string name="HeapSort11">have a corresponding relationship as shown in the diagram.</string>
    <string name="HeapSort15">As you can see, it could be said that the heap is just crammed into an array.</string>
    <string name="HeapSort16">"Now, let's try sorting the array using the swapping method."</string>
    <string name="HeapSort17">"To make things easier to understand, we'll keep the tree structure of the heap visible."</string>
    <string name="HeapSort18">"As before, we'll begin by storing the numbers in a heap."</string>
    <string name="HeapSort20">As the numbers in the tree-structured heap swap around, so too do the corresponding numbers in the array.</string>
    <string name="HeapSort21">All numbers have been stored in the heap. At the same time, we were able to arrange the array in a descending-order heap structure.</string>
    <string name="HeapSort22">Next, the numbers stored in the heap are taken out one by one.</string>
    <string name="HeapSort23">Descending-order heaps have their data removed in order starting from the largest values.</string>
    <string name="HeapSort24">The first number in the array is the largest number in the heap.</string>
    <string name="HeapSort25">The first number in the array gets swapped with the number that corresponds to the last element in the heap, completing the operation.</string>
    <string name="HeapSort26">The heap is reorganized so that its structure is maintained.</string>
    <string name="HeapSort27">This operation repeats until all of the numbers have been fully sorted.</string>
    <string name="HeapSort28">Sorting is complete.</string>
    <string name="HeapSort29">This concludes the explanation of heap sort.</string>
    <string name="HeapSort3">All numbers have been stored in a heap.</string>
    <string name="HeapSort4">Next, the numbers stored in the heap are taken out one by one.</string>
    <string name="HeapSort5">One property of descending heaps is that numbers are removed from largest to smallest, so if you line the numbers up in the opposite order (right-to-left) as they get removed, sorting is complete.</string>
    <string name="HeapSort7">All of the numbers were removed from the heap, and sorting is complete.</string>
    <string name="HeapSort8">While we prepared an extra heap data structure apart from the sequence of numbers this time...</string>
    <string name="HeapSort9">normally, the heap is incorporated into the very array containing the sequence of numbers, and sorting is carried out by simply swapping the numbers around.</string>
    <string name="Huffman">Huffman(哈夫曼)编码</string>
    <string name="Huffman0">\"Huffman coding\" is one algorithm used to encode data.</string>
    <string name="Huffman1">"It's used for things like image and file compression in JPEG and ZIP formats."</string>
    <string name="Huffman10">As a simple example, we come up with the encoding rule in the diagram. One character is expressed with 2 bits.</string>
    <string name="Huffman100">The same operation is repeated with \"C or D\" considered as one character.</string>
    <string name="Huffman101">Two characters are found in the order of lowest frequency from among the 3 remaining: \"A\", \"B\", and \"C or D\".</string>
    <string name="Huffman102" formatted="false">This time, they are \"A\" (35%) and \"B\" (25%).</string>
    <string name="Huffman103">The two characters are connected with a line to create a tree structure.</string>
    <string name="Huffman104">The two characters are combined into \"A or B\", and their frequencies are added together.</string>
    <string name="Huffman105">\"A or B\" will be considered one character.</string>
    <string name="Huffman106">"In the same manner, the 2 characters with the lowest frequencies are chosen, but they're the last 2 characters left: \"A or B\" and \"C or D\"."</string>
    <string name="Huffman107">The two are connected with a line to create a tree structure.</string>
    <string name="Huffman108">All characters have become one as \"A or B or C or D\". Its frequency of appearance is, of course, 100%.</string>
    <string name="Huffman109">Now, the tree structure that facilitates Huffman coding is complete.</string>
    <string name="Huffman11">We try encoding \"ABAABACD\" according to our rules. It resulted in a data size of 16 bits, which is quite a reduction.</string>
    <string name="Huffman110">"Each character's frequency of appearance has been displayed once again."</string>
    <string name="Huffman111">Codes \"0\" and \"1\" are assigned to the branches extending up and down.</string>
    <string name="Huffman112">Next, the tree is traversed from its roots to each character, a corresponding code being settled on for each one.</string>
    <string name="Huffman113">In the case of \"A\", the code assigned to it is \"00\".</string>
    <string name="Huffman114">In the case of \"B\", the code assigned to it is \"01\".</string>
    <string name="Huffman115">In the case of \"C\", the code assigned to it is \"10\".</string>
    <string name="Huffman116">In the case of \"D\", the code assigned to it is \"11\".</string>
    <string name="Huffman117">Encoding with Huffman coding is now complete.</string>
    <string name="Huffman118">"The tree structure is different from the last example, and because there aren't any large differences in frequency of appearance between characters, all characters are expressed with 2-bit codes."</string>
    <string name="Huffman119">For example, even if we try to express \"C\" and \"D\" with 3 bits in order to express the highest frequency character, \"A\", with 1 bit...</string>
    <string name="Huffman12">"Of course, because they're rules we just made up, we'll need to communicate the encoding rules to the side receiving the character string."</string>
    <string name="Huffman120" formatted="false">because the frequency of \"C or D\" (40%) is higher than the frequency of \"A\" (35%), the encoding efficiency gets worse.</string>
    <string name="Huffman121">As you can see, Huffman coding is capable of simple and efficient encoding based on character frequency.</string>
    <string name="Huffman122">This concludes the explanation of Huffman coding.</string>
    <string name="Huffman13">"For convenience, in this explanation we'll ignore how much network traffic it takes to transmit the encoding rules."</string>
    <string name="Huffman14">In order for the side receiving the character string to decode it...</string>
    <string name="Huffman15">if they divide the code into 2-character segments...</string>
    <string name="Huffman16">and decode it by checking each segment against the rules, the original character string \"ABAABACD\" can be extracted.</string>
    <string name="Huffman17">"Let's consider encoding the character string \"ABAABACD\" to be even smaller."</string>
    <string name="Huffman18">With the earlier rules, we expressed one character with 2 bits...</string>
    <string name="Huffman19">but it seems that by expressing \"A\" and \"B\" with 1 bit, we can encode them to be even smaller.</string>
    <string name="Huffman2">"As an example, let's imagine we want to send the character string \"ABAABACD\" over a network."</string>
    <string name="Huffman20">Furthermore, in the character string \"ABAABACD\", the characters \"A\" and \"B\" are used more than characters \"C\" and \"D\".</string>
    <string name="Huffman21">Therefore, it seems like it would be better to express \"A\" and \"B\" with 1 bit rather than \"C\" and \"D\", anyway.</string>
    <string name="Huffman22">We try encoding \"ABAABACD\" according to our rules. It resulted in a data size of 10 bits, which is even more of a reduction.</string>
    <string name="Huffman23">In order for the side receiving the code to decode it into a character string...</string>
    <string name="Huffman24">each character should be checked against the conversion rules and decoded...</string>
    <string name="Huffman25">but the code \"10\", for example, can express either \"BA\" or \"C\".</string>
    <string name="Huffman26">Due to this, a different character string was extracted.</string>
    <string name="Huffman27">There are various other character strings that can be extracted as well, and the original character string cannot be unambiguously determined.</string>
    <string name="Huffman28">When the original characters cannot be unambiguously determined from code, it is called \"not uniquely decodable\".</string>
    <string name="Huffman29">"Let's consider another example. For convenience, let's assume that the 2 characters \"A\" and \"B\" will be encoded as in the diagram."</string>
    <string name="Huffman3">The data will be encoded in binary as 0s and 1s.</string>
    <string name="Huffman30">"Let's consider the steps for decoding the code \"000001\" according to these encoding rules."</string>
    <string name="Huffman31">When decoding, we look at the numbers in order from the beginning.</string>
    <string name="Huffman32">"The first number is \"0\", but we can't determine whether this stands for an \"A\" or part of a \"B\"."</string>
    <string name="Huffman33">"The first 2 numbers are \"00\", but we can't determine whether these stand for \"AA\" or part of a \"B\"."</string>
    <string name="Huffman34">"The first 3 numbers are \"000\", but again, we can't determine whether these stand for \"AAA\" or part of a \"B\"."</string>
    <string name="Huffman35">"Likewise, we can't make a determination with the first 4 numbers..."</string>
    <string name="Huffman36">nor with the first 5 numbers.</string>
    <string name="Huffman37">Finally, we see the 6th number, \"1\", and determine that the first \"0\" is an \"A\", and that the \"00001\" following it stands for \"B\".</string>
    <string name="Huffman38">"We can unambiguously decode the numbers \"000001\" into the character string \"AB\". At this point, there's no issue."</string>
    <string name="Huffman39">Codes in a conversion table whose original characters can be determined as soon as they appear are called \"instantaneous codes\"...</string>
    <string name="Huffman4">For example, in ASCII character code, the characters \"A\", \"B\", \"C\", and \"D\" are encoded as shown in the diagram.</string>
    <string name="Huffman40">but, as in this example, those whose original characters cannot be determined without checking later characters are not instantaneous codes.</string>
    <string name="Huffman41">Thus, decoding takes some time.</string>
    <string name="Huffman42">For the sake of efficient encoding/decoding, codes that are uniquely decodable and instantaneous codes are preferred.</string>
    <string name="Huffman43">"Let's consider where the problems lay in the 2 encoding rules used as examples in the diagrams."</string>
    <string name="Huffman44">If we try visualizing the first set of encoding rules...</string>
    <string name="Huffman45">"if the first character in a given code is \"0\", we determine that it's an \"A\"."</string>
    <string name="Huffman46">"However, if it's a \"1\", it could be a \"B\", or possibly part of a \"C\" or \"D\"."</string>
    <string name="Huffman47">"Let's try visualizing the second set of encoding rules in the same way."</string>
    <string name="Huffman48">Given any code, the first character can only be \"0\".</string>
    <string name="Huffman49">However, that \"0\" could be an \"A\" or part of a \"B\".</string>
    <string name="Huffman5">In ASCII, one character is expressed with 8 bits.</string>
    <string name="Huffman50">In order for something to be uniquely decodable and instantaneous code, there has to be the condition that \"no code will be part of the beginning of another code\".</string>
    <string name="Huffman51">The previous two examples did not meet that condition.</string>
    <string name="Huffman52">Huffman coding is an algorithm that easily guides us to codes that are uniquely decodable and instantaneous codes.</string>
    <string name="Huffman53">"Let's take a look at some actual encoding with Huffman coding."</string>
    <string name="Huffman54">Huffman coding produces uniquely decodable and instantaneous codes.</string>
    <string name="Huffman55">"First, each character's frequency of appearance is calculated. The frequencies are shown in the diagram for the case of \"ABAABACD\"."</string>
    <string name="Huffman56">Next, the characters are arranged in order of highest frequency. In this example, they happen to fall in the default order of \"ABCD\".</string>
    <string name="Huffman57">Next, two characters are found in the order of lowest frequency.</string>
    <string name="Huffman58" formatted="false">In this case, they are \"C\" (12.5%) and \"D\" (12.5%).</string>
    <string name="Huffman59">The two characters are connected with a line to create a tree structure.</string>
    <string name="Huffman6">Using ASCII, we encoded the character string \"ABAABACD\". It resulted in a data size of 64 bits.</string>
    <string name="Huffman60">The two characters are combined into \"C or D\", and their frequencies are added together.</string>
    <string name="Huffman61">The same operation is repeated with \"C or D\" considered as one character.</string>
    <string name="Huffman62">Two characters are found in the order of lowest frequency from among the 3 remaining: \"A\", \"B\", and \"C or D\".</string>
    <string name="Huffman63" formatted="false">This time, they are \"B\" (25%) and \"C or D\" (25%).</string>
    <string name="Huffman64">The two characters are connected with a line to create a tree structure.</string>
    <string name="Huffman65">The two characters are combined into \"B or C or D\", and their frequencies are added together.</string>
    <string name="Huffman66">\"B or C or D\" will be considered one character.</string>
    <string name="Huffman67">"In the same manner, the 2 characters with the lowest frequencies are chosen, but they're the last 2 characters left: \"A\" and \"B or C or D\"."</string>
    <string name="Huffman68">The two are connected with a line to create a tree structure.</string>
    <string name="Huffman69">All characters have become one as \"A or B or C or D\". Its frequency of appearance is, of course, 100%.</string>
    <string name="Huffman7">"In order to minimize network traffic, let's consider encoding the 64-bit character string into something smaller."</string>
    <string name="Huffman70">Now, the tree structure that facilitates Huffman coding is complete.</string>
    <string name="Huffman71">"Each character's frequency of appearance has been displayed once again."</string>
    <string name="Huffman72">"Next, we'll move to encoding using 0s and 1s."</string>
    <string name="Huffman73">Codes \"0\" and \"1\" are assigned to the branches extending up and down.</string>
    <string name="Huffman74">"It doesn't matter if the assignment of 0s and 1s is the other way around. However, if you decide to make the upper branches \"1\", you can't change the assignment pattern midway through."</string>
    <string name="Huffman75">All codes have been assigned.</string>
    <string name="Huffman76">Next, the tree is traversed from its roots to each character, a corresponding code being settled on for each one.</string>
    <string name="Huffman77">In the case of \"A\"...</string>
    <string name="Huffman78">the code assigned to it is \"0\".</string>
    <string name="Huffman79">In the case of \"B\"...</string>
    <string name="Huffman8">In order to distinguish and handle a large number of characters, ASCII expresses one character with 8 bits.</string>
    <string name="Huffman80">the code assigned to it is \"10\".</string>
    <string name="Huffman81">In the case of \"C\"...</string>
    <string name="Huffman82">the code assigned to it is \"110\".</string>
    <string name="Huffman83">In the case of \"D\"...</string>
    <string name="Huffman84">the code assigned to it is \"111\".</string>
    <string name="Huffman85">Encoding with Huffman coding is now complete.</string>
    <string name="Huffman86">This means that the character string \"ABAABACD\" should be encoded using these rules.</string>
    <string name="Huffman87">"It's obvious from the tree structure that \"no code will be part of the beginning of another code\"."</string>
    <string name="Huffman88">Thus, they are uniquely decodable and instantaneous codes.</string>
    <string name="Huffman89">Also, because codes with smaller numbers of bits are assigned to the characters with higher frequencies of appearance, we can see that the encoding is efficient.</string>
    <string name="Huffman9">However, only 4 characters are used in the character string \"ABAABACD\". It seems that we should encode these 4 characters in a distinguishable way.</string>
    <string name="Huffman90" formatted="false">To be more concrete, in this example, \"C or D\" (25%) has a lower frequency of appearance than \"A\" (50%).</string>
    <string name="Huffman91">Thus, even if \"C or D\" is expressed with 3 bits, expressing \"A\" with 1 bit is more efficient, which is reflected in the results.</string>
    <string name="Huffman92">"Let's try encoding \"ABAABACD\" using the rules we ordained."</string>
    <string name="Huffman93">The result is 14 bits, which is even shorter than when we expressed each character with 2 bits.</string>
    <string name="Huffman94">"Let's try looking at another example. This time, there won't be a big difference between characters as far as frequency of appearance."</string>
    <string name="Huffman95">For convenience, the frequency of appearance lessens in the same order as the character string. Therefore, there is no need to rearrange it.</string>
    <string name="Huffman96">Next, two characters with the lowest frequencies are found.</string>
    <string name="Huffman97" formatted="false">In this case, they are \"C\" (22%) and \"D\" (18%).</string>
    <string name="Huffman98">The two characters are connected with a line to create a tree structure.</string>
    <string name="Huffman99">The two characters are combined into \"C or D\", and their frequencies are added together.</string>
    <string name="HuffmanDescription">\"Huffman coding\" is an algorithm used in file formats like JPEG and ZIP. You can study this topic after purchasing all of the algorithms.</string>
    <string name="HybridEncoding">Hybrid Cryptosystem</string>
    <string name="HybridEncoding0">"With the shared-key cryptosystem, there's the key delivery problem of how to exchange keys securely."</string>
    <string name="HybridEncoding1">On the other hand, with the public-key cryptosystem, there was the problem of slow processing during encryption and decryption.</string>
    <string name="HybridEncoding10">By encrypting this key with the public-key cryptosystem, it can be securely sent to party B.</string>
    <string name="HybridEncoding11">Party B, the receiver, creates the public and secret keys.</string>
    <string name="HybridEncoding12">The public key is sent to party A.</string>
    <string name="HybridEncoding13">Party A uses the public key they received from party B...</string>
    <string name="HybridEncoding14">and encrypts the key to be used with the shared-key cryptosystem.</string>
    <string name="HybridEncoding15">The encrypted key is sent to party B.</string>
    <string name="HybridEncoding16">Party B uses their secret key...</string>
    <string name="HybridEncoding17">and decrypts the ciphertext containing the key.</string>
    <string name="HybridEncoding18">In this way, party A was able to securely send the key used in the public-key cryptosystem to party B.</string>
    <string name="HybridEncoding19">The only thing left to do now is use this key and send the encrypted data.</string>
    <string name="HybridEncoding2">"The \"hybrid cryptosystem\" is a system that combines the two in order to make up for each one's faults."</string>
    <string name="HybridEncoding20">"The shared-key cryptosystem's faster processing is used to encrypt the data."</string>
    <string name="HybridEncoding21">Party B was able to obtain the original data without issue.</string>
    <string name="HybridEncoding22">In this way, the hybrid cryptosystem combines both security and fast processing.</string>
    <string name="HybridEncoding23">"As it's used in SSL, a system that enables the secure exchange of information over the internet, it's a cryptosystem we can't live without."</string>
    <string name="HybridEncoding24">This concludes the explanation of the hybrid cryptosystem.</string>
    <string name="HybridEncoding3">It uses a shared-key cryptosystem that quickly processes data encryption.</string>
    <string name="HybridEncoding4">However, the keys used by the shared-key cryptosystem are exchanged using the more secure public-key cryptosystem.</string>
    <string name="HybridEncoding5">"Let's take a more concrete look at the hybrid cryptosystem in action."</string>
    <string name="HybridEncoding6">"Let's say that party A wants to send data to party B over the internet."</string>
    <string name="HybridEncoding7">The data is encrypted with the faster processing of the shared-key cryptosystem.</string>
    <string name="HybridEncoding8">Because the key needed for encryption is also used for decryption, party A needs to send the key to party B.</string>
    <string name="HybridEncoding9">The key is also a form of data.</string>
    <string name="HybridEncodingDescription">The \"hybrid cryptosystem\" is a method that combines the shared-key and public-key cryptosystems. You can study this topic after purchasing all of the algorithms.</string>
    <string name="IABSetUpFailed">连接谷歌商店失败！ 请确定您已经登录了您的谷歌帐号。</string>
    <string name="Inquiry">反馈</string>
    <string name="InquiryConfirmation">确认</string>
    <string name="InquiryEmail">邮件地址</string>
    <string name="InquiryFailed">发送消息的时候出现了一个错误！请稍候再试。</string>
    <string name="InquiryIsSendOK">发送您的反馈？</string>
    <string name="InquiryName">姓名</string>
    <string name="InquiryOptional">(optional)</string>
    <string name="InquiryPleaseInput">请在输入框里输入您的反馈信息</string>
    <string name="InquiryPleaseSmall">反馈内容不得超过1000个字符！</string>
    <string name="InquirySend">发送</string>
    <string name="InquirySuccess">感谢您的反馈. 这将会帮助我们对应用进行改进,使它变得更好用.</string>
    <string name="InquirySuccessTitle">发送反馈</string>
    <string name="InsertionSort">插入排序</string>
    <string name="InsertionSort0">\"插入排序\"是一种对数列进行排序的算法.</string>
    <string name="InsertionSort1">我们先假设第一个数是已经排好序的.</string>
    <string name="InsertionSort10">然后把它和它左边的数进行比较.</string>
    <string name="InsertionSort11">5比4大,所以我们交换这两个数的位置.</string>
    <string name="InsertionSort12">3比4小.一个比4小的数出现了,所以我们停止对4进行移动.</string>
    <string name="InsertionSort13">现在4也被认为是排好序的数了.</string>
    <string name="InsertionSort14">对剩下的数进行同样的操作,直到所有的数都被排好序.</string>
    <string name="InsertionSort18">所有的数都被排好序了,于是排序到这里就完成了.</string>
    <string name="InsertionSort19">这就是插入排序.</string>
    <string name="InsertionSort2">然后,我们从剩下的数列中取出最左边的数...</string>
    <string name="InsertionSort3">并和这个数左边的数进行比较.</string>
    <string name="InsertionSort4">如果它比它左边的数要小,那么把它们的位置进行交换.</string>
    <string name="InsertionSort5">重复这个操作,直到遇到一个比它小的数,或者已经移到数列的最左(右)端.</string>
    <string name="InsertionSort6">在这个例子中,5比3大,于是交换它们的位置.</string>
    <string name="InsertionSort7">3已经移到了最左端,我们就可以停止对3进行移动了.</string>
    <string name="InsertionSort8">3也被认为是排好序的数了.</string>
    <string name="InsertionSort9">和之前的步骤相同,我们又从剩下的数列中取出最左边的数...</string>
    <string name="KmeansClustering">k-means Algorithm</string>
    <string name="KmeansClustering0">The \"k-means algorithm\" is one type of algorithm used in graph clustering.</string>
    <string name="KmeansClustering1">Clustering is an operation that, when given a set of data...</string>
    <string name="KmeansClustering10">The 3 cluster center points are set in random locations.</string>
    <string name="KmeansClustering100">The shortest distances to center points are calculated once again, and the data points are regrouped into clusters.</string>
    <string name="KmeansClustering101">In clustering, each group is called a \"cluster\".</string>
    <string name="KmeansClustering11">"From each data point, we calculate the distance to the nearest cluster's center."</string>
    <string name="KmeansClustering12">Each data point is grouped under one of the predetermined clusters.</string>
    <string name="KmeansClustering13">The mean of the data points in each cluster is calculated, and the center point of the cluster is moved there.</string>
    <string name="KmeansClustering14">"Due to this relocation of the center points, it's possible that the nearest center point may change for some data points."</string>
    <string name="KmeansClustering15">This process of assigning each data point to a cluster and moving the center point to the mean of the group repeats until convergence of the center points has been reached.</string>
    <string name="KmeansClustering2">classifies similar data into groups.</string>
    <string name="KmeansClustering26">Convergence of the center points has been reached, so the operation finishes.</string>
    <string name="KmeansClustering27">It is mathematically proven that as the operation repeats, center points will converge somewhere.</string>
    <string name="KmeansClustering28">Clustering is now complete.</string>
    <string name="KmeansClustering29">We can see that the data points have been appropriately grouped with other similar points.</string>
    <string name="KmeansClustering3">The basis for similarity varies according to the algorithm, depending on things like distance between data points or their coordinates.</string>
    <string name="KmeansClustering30">"Now let's try running the k-means algorithm on the same data with only 2 clusters and see what happens."</string>
    <string name="KmeansClustering31">We set the center points randomly...</string>
    <string name="KmeansClustering32">and repeat the process of assigning each data point to a cluster and moving the center point to the mean of the group until convergence of the center points has been reached.</string>
    <string name="KmeansClustering4">The k-means algorithm uses the distance from the center of each cluster to classify the data.</string>
    <string name="KmeansClustering43">Convergence of the center points has been reached.</string>
    <string name="KmeansClustering44">This time, 2 groups of data, the left one and the lower one, have been lumped together into one cluster.</string>
    <string name="KmeansClustering45">As you can see, because the number of clusters must be set before the k-means algorithm starts, if the number is not set appropriately, there are times when no significant results can be obtained.</string>
    <string name="KmeansClustering46">There are a number of techniques used to guess at the appropriate number of clusters, like analyzing the data beforehand, or simply running the algorithm multiple times, changing the number of clusters each time.</string>
    <string name="KmeansClustering47">"Moving on, let's try running the k-means algorithm one more time using the same data, but with our initial center points in different locations than before."</string>
    <string name="KmeansClustering48">Once again, we repeat the process of assigning each data point to a cluster and moving the center point to the mean of the group until convergence of the center points has been reached.</string>
    <string name="KmeansClustering5">"Now then, let's take a look at the algorithm in action."</string>
    <string name="KmeansClustering58">Convergence of the center points has been reached.</string>
    <string name="KmeansClustering59">In contrast to the previous run, the two groups in the upper and lower right corners have been lumped together into one cluster.</string>
    <string name="KmeansClustering6">First, we prepare the data for clustering.</string>
    <string name="KmeansClustering60">As you can see, clustering results differing due to the random placement of the initial center point locations is a characteristic of the k-means algorithm.</string>
    <string name="KmeansClustering61">This concludes the explanation of the k-means algorithm.</string>
    <string name="KmeansClustering7">Next, we decide on the number of clusters.</string>
    <string name="KmeansClustering8">Deciding on the number of clusters beforehand is a characteristic of the k-means algorithm.</string>
    <string name="KmeansClustering9">"This time we'll use 3 clusters."</string>
    <string name="KmeansClusteringDescription">The \"k-means algorithm\" is a simple but widely used method of data analysis. You can study this topic after purchasing all of the algorithms.</string>
    <string name="LangColon">语言:</string>
    <string name="LetsUnlock">"购买之后即可学习所有的算法主题。让我们一起来学习算法吧！"</string>
    <string name="LinearSearch">线性查找</string>
    <string name="LinearSearch0">\"Linear search\" is an algorithm for searching through elements of an array.</string>
    <string name="LinearSearch1">"Let's try searching for the number 6."</string>
    <string name="LinearSearch2">First, we examine the leftmost number in the array.</string>
    <string name="LinearSearch3">"We compare it with 6, and if it matches, the search ends. If it doesn't match, we examine the next number to the right."</string>
    <string name="LinearSearch4">We repeat the comparisons until the 6 is found.</string>
    <string name="LinearSearch5">We found the 6, so the search ends.</string>
    <string name="LinearSearch6">As you can see, linear search is a simple technique for doing repeated comparisons in order from the beginning.</string>
    <string name="LinearSearch7">"When there's a lot of data, the number of comparisons increases, and it takes more time."</string>
    <string name="LinearSearch8">This concludes the explanation of linear search.</string>
    <string name="List">Lists</string>
    <string name="List0">\"Lists\" are one type of data structure, and can store multiple values.</string>
    <string name="List1">"They are unique in how they pair data with \"pointers\", the pointers indicating the next piece of data's memory location."</string>
    <string name="List12">This concludes the explanation of lists.</string>
    <string name="List2">In lists, data is stored in various disjointed locations in memory.</string>
    <string name="List4">Because data is stored in different locations, each piece of data can only be accessed through the pointer that precedes it.</string>
    <string name="List9">Addition of data is performed simply by replacing the pointers on either side of the addition.</string>
    <string name="ListSearchSection">List Search</string>
    <string name="MAC">Message Authentication Codes</string>
    <string name="MAC0">\"Message authentication codes\" are a system that implements two functions, authentication and falsification detection.</string>
    <string name="MAC1">"First, let's take a look at a situation in which message authentication codes are necessary."</string>
    <string name="MAC10">The ciphertext is sent to party B...</string>
    <string name="MAC11">who decrypts the ciphertext and obtains the message containing the product code.</string>
    <string name="MAC12">While there were no problems in this case, the following can happen.</string>
    <string name="MAC13">"Let's rewind to the point where party A sends the ciphertext to party B."</string>
    <string name="MAC14">"Let's say that malicious party X..."</string>
    <string name="MAC15">falsified the ciphertext that party A was trying to send to party B during transmission.</string>
    <string name="MAC16">"Party B receives the ciphertext, but has no way of realizing that it's been falsified."</string>
    <string name="MAC17">When party B decrypts the ciphertext, the message reads \"xyz\".</string>
    <string name="MAC18">Believing that \"xyz\" is the product code ordered, party B ships the incorrect product to party A.</string>
    <string name="MAC19">"Because encryption is no more than a process of computing values, decryption calculations can still be performed on ciphertext that's been falsified."</string>
    <string name="MAC2">In order to buy a product from party B, party A sends a message that displays the product code \"abc\".</string>
    <string name="MAC20">"If the original message was a long sentence, and the falsified message becomes some meaningless sentence, there's a possibility that someone will notice the falsification."</string>
    <string name="MAC21">However, with data that humans have no direct understanding of, like product codes, it can be difficult to catch such falsifications after the decryption.</string>
    <string name="MAC22">In order to detect falsifications, an extra measure beyond encryption is necessary.</string>
    <string name="MAC23">"If you use message authentication codes, you can detect falsifications. Let's take a look at how they work."</string>
    <string name="MAC24">We return once more to the point where party A sends the ciphertext to party B.</string>
    <string name="MAC25">Party A creates a key that will be used to create a message authentication code...</string>
    <string name="MAC26">and sends the key to party B using a secure method.</string>
    <string name="MAC27">Next, party A creates a value using the ciphertext and key...</string>
    <string name="MAC28">and the value \"7f05\" was obtained.</string>
    <string name="MAC29">This value created by combining the key and ciphertext is called a \"message authentication code\".</string>
    <string name="MAC3">Party A encrypts the message.</string>
    <string name="MAC30">It is regularly abbreviated as \"MAC\", and will be written as such for the remainder of this explanation.</string>
    <string name="MAC31">A MAC could be imagined as something like the \"hash value\" of a character string composed of the key and the ciphertext.</string>
    <string name="MAC32">A more detailed explanation of \"hash values\" can be found elsewhere in this app.</string>
    <string name="MAC33">"There are a variety of ways to create MACs, such as \"HMAC\", \"OMAC\", and \"CMAC\". These days, the \"HMAC\"method is what's often used."</string>
    <string name="MAC34">Party A sends party B the MAC they created along with the ciphertext.</string>
    <string name="MAC35">Party B received the ciphertext and the MAC.</string>
    <string name="MAC36">Now party B needs to check to see whether or not the ciphertext has been falsified.</string>
    <string name="MAC37">Like party A did, party B also uses the ciphertext and key to create a MAC.</string>
    <string name="MAC38">Party B was able to confirm that the MAC they created themselves matched the MAC received from party A.</string>
    <string name="MAC39">Therefore, party B knows that the ciphertext they received has not been falsified.</string>
    <string name="MAC4">"Let's say they use the shared-key cryptosystem for the encryption."</string>
    <string name="MAC40">"All that's left is to use the ciphertext's key and decrypt the message."</string>
    <string name="MAC41">The message containing the product code \"abc\" that party A ordered was successfully extracted without issue.</string>
    <string name="MAC42">"Let's return to the point at which party A sends the ciphertext to party B."</string>
    <string name="MAC43">"Let's see what happens if malicious party X attempts to falsify the message during transmission."</string>
    <string name="MAC44">"Let's say that between the ciphertext and MAC that party A sent to party B..."</string>
    <string name="MAC45">party X falsified the ciphertext.</string>
    <string name="MAC46">However, when party B calculates the MAC on their side again...</string>
    <string name="MAC47">"they realize that it doesn't match the MAC they received from party A."</string>
    <string name="MAC48">From this, party B knows that the ciphertext, the MAC, or both could have been falsified.</string>
    <string name="MAC49">"In this case, it's best to discard the ciphertext and the MAC and request that party A resend them."</string>
    <string name="MAC5">Party A passes this key along to party B using a secure method.</string>
    <string name="MAC50">"So, is it possible for party X to falsify the MAC as well, so that it's consistent with the falsified ciphertext?"</string>
    <string name="MAC51">"Because party X doesn't have the key used to create the MAC..."</string>
    <string name="MAC52">"even if they are able to falsify it, it still isn't possible to make it consistent with the falsified ciphertext."</string>
    <string name="MAC53">"As expected, when party B recalculates the MAC and it doesn't match the MAC paired with the falsified ciphertext, it's clear that some kind of falsification occurred during transmission."</string>
    <string name="MAC55">As you can see, by making use of message authentication codes, or MACs, we can prevent falsification during transmission.</string>
    <string name="MAC56">However, there are flaws even with message authentication codes.</string>
    <string name="MAC57">"Let's try simplifying the process."</string>
    <string name="MAC58">First, party A and party B both share the key used to encrypt the message and calculate the MAC.</string>
    <string name="MAC59">Therefore...</string>
    <string name="MAC6">Key exchange methods use protocols such as the public-key cryptosystem or the Diffie-Hellman key exchange.</string>
    <string name="MAC60">just as party A can encrypt the message and calculate a MAC...</string>
    <string name="MAC63">so too can party B encrypt the message and calculate a MAC.</string>
    <string name="MAC66">"In other words, you can't verify whether it was party A or party B who created the original message."</string>
    <string name="MAC67">Therefore, if it were the case that party A was malicious...</string>
    <string name="MAC68">once the message was sent, they can claim that it was fabricated by party B, allowing them to \"repudiate\" the fact that they sent the message themselves.</string>
    <string name="MAC7">Both the public-key cryptosystem and the Diffie-Hellman key exchange are explained in more detail elsewhere in this app.</string>
    <string name="MAC71">"In order to prevent this kind of repudiation, it's necessary to use \"digital signatures\", which are explained elsewhere in this app."</string>
    <string name="MAC72">This concludes the explanation of message authentication codes.</string>
    <string name="MAC8">Party A uses the shared key and encrypts the message.</string>
    <string name="MarkAllAsRead">标记所有主题为已读</string>
    <string name="MarkAllAsUnread">标记所有主题为未读</string>
    <string name="MathSection">数学</string>
    <string name="MergeSort">归并排序</string>
    <string name="MergeSort0">\"Merge sort\" is one algorithm used to sort a sequence of numbers.</string>
    <string name="MergeSort1">First, the sequence is divided further and further into halves.</string>
    <string name="MergeSort10">When groups with multiple numbers are combined, the first numbers are compared.</string>
    <string name="MergeSort11">In the diagram, first numbers 4 and 3 will be compared.</string>
    <string name="MergeSort12">4 is greater than 3, so the 3 is moved.</string>
    <string name="MergeSort13">The remaining rows have their first numbers compared in the same way...</string>
    <string name="MergeSort14">4 is less than 7, so the 4 is moved.</string>
    <string name="MergeSort15">6 is less than 7, so the 6 is moved.</string>
    <string name="MergeSort16">The remaining 7 is moved.</string>
    <string name="MergeSort17">The combining of groups is repeated recursively until all numbers form one group.</string>
    <string name="MergeSort22">Combining is complete, and the sequence has been sorted.</string>
    <string name="MergeSort23">This concludes the explanation of merge sort.</string>
    <string name="MergeSort5">The divisions are complete.</string>
    <string name="MergeSort6">Next, the divided groups are combined.</string>
    <string name="MergeSort7">"When being combined, each group's numbers are arranged so that they're ordered from smallest to largest after combination."</string>
    <string name="MergeSortDescription">\"Merge sort\" is unique in how it divides a sequence of numbers into smaller groups and then puts them in order. You can study this topic after purchasing all of the algorithms.</string>
    <string name="NowBuying">加载中...</string>
    <string name="OthersSection">其他</string>
    <string name="PKC">Public-Key Cryptosystem</string>
    <string name="PKC0">The \"public-key cryptosystem\" is an encryption system that uses different keys for encryption and decryption.</string>
    <string name="PKC1">The key used for encryption is called a \"public key\", and the key used for decryption is called a \"secret key\".</string>
    <string name="PKC10">The ciphertext is sent to party B.</string>
    <string name="PKC11">Party B uses the secret key and decrypts the ciphertext received from party A.</string>
    <string name="PKC12">Party B has now obtained the original data.</string>
    <string name="PKC13">Because public keys and ciphertext are sent over the internet...</string>
    <string name="PKC14">"there's a chance that they'll be intercepted by a malicious third party X."</string>
    <string name="PKC15">"However, because ciphertext can't be decrypted with a public key, party X can't obtain the original data."</string>
    <string name="PKC16">"Thus, unlike the shared-key cryptosystem, the key delivery problem doesn't occur with the public-key cryptosystem."</string>
    <string name="PKC17">"The public-key cryptosystem has an additional merit of making it easy to exchange information among an unspecified number of parties. Let's take a more concrete look."</string>
    <string name="PKC18">"Let's say that party B has prepared public and secret keys in advance."</string>
    <string name="PKC19">"Having the public key known by others doesn't present a problem."</string>
    <string name="PKC2">Compared to the shared-key cryptosystem, the public-key cryptosystem tends to take more time for both encryption and decryption.</string>
    <string name="PKC20">Thus, party B can publish the public key on the internet.</string>
    <string name="PKC21">"On the other hand, the secret key can't be known by others, so it needs to be tightly guarded."</string>
    <string name="PKC22">"Let's say that there are multiple people who want to send data to party B."</string>
    <string name="PKC23">The people sending data obtain the public key shared by party B...</string>
    <string name="PKC24">and encrypt the data they want to send.</string>
    <string name="PKC25">They send their ciphertext to party B.</string>
    <string name="PKC26">Party B uses the secret key and decrypts their ciphertext.</string>
    <string name="PKC27">Party B has now obtained the original data.</string>
    <string name="PKC28">"As you can see, there's no need to prepare a key for each person sending data."</string>
    <string name="PKC29">Also, because the receiver of the data is the only party who has the key needing kept private, it has a high level of security.</string>
    <string name="PKC3">Some examples of calculation methods for public-key encryption are shown in the diagram.</string>
    <string name="PKC30">However, there are 2 problems with the public-key cryptosystem.</string>
    <string name="PKC31">The 1st problem is that it takes time for both encryption and decryption.</string>
    <string name="PKC32">"Because of this, it isn't suited for exchanging small amounts of data back and forth."</string>
    <string name="PKC33">As a solution to this problem, there is the \"hybrid cryptosystem\", which is explained in more detail elsewhere in this app.</string>
    <string name="PKC34">The 2nd problem relates to the reliability of public keys.</string>
    <string name="PKC35">"Let's rewind to the point where party B had created public and secret keys."</string>
    <string name="PKC36">"For convenience, we'll represent the public key created by party B with \"PB\", and the secret key with \"SB\"."</string>
    <string name="PKC37">Party X, who wants to intercept the data party A is sending to party B, creates public key \"PX\" and secret key \"SX\".</string>
    <string name="PKC38">When party B goes to send public key PB to party A...</string>
    <string name="PKC39">party X secretly replaces public key PB with the public key PX that they created...</string>
    <string name="PKC4">Today, RSA encryption is widely used, and is explained in more detail elsewhere in this app.</string>
    <string name="PKC40">and gives public key PX to party A.</string>
    <string name="PKC41">"There's no way to show who a public key was created by."</string>
    <string name="PKC42">Therefore, party A is unable to tell that the public key they received was secretly swapped in.</string>
    <string name="PKC43">Party A encrypts data with public key PX.</string>
    <string name="PKC44">When party A goes to send the ciphertext to party B...</string>
    <string name="PKC45">party X receives this ciphertext.</string>
    <string name="PKC46">Because this ciphertext was encrypted with the public key PX that party X prepared...</string>
    <string name="PKC47">party X can decrypt it with the secret key SX in their possession.</string>
    <string name="PKC48">Now party X has successfully intercepted the data party A was trying to send to party B.</string>
    <string name="PKC49">"Next, party X encrypts the data with party B's public key PB."</string>
    <string name="PKC5">"Let's look at the broader picture of how data is exchanged using the public-key cryptosystem"</string>
    <string name="PKC50">The resulting ciphertext is given to party B.</string>
    <string name="PKC51">Since this ciphertext was created with public key PB that party B prepared, party B can decrypt it with the secret key SB they possess.</string>
    <string name="PKC52">Because party B was able to decrypt the ciphertext, they never even dream that the data was intercepted by someone else.</string>
    <string name="PKC53">This attack method of intercepting data by secretly replacing public keys on-the-fly is called a \"man-in-the-middle attack\".</string>
    <string name="PKC54">"The problem is rooted in the fact that party A can't verify whether or not the public key they received was created by party B."</string>
    <string name="PKC55">To solve this problem, a system of \"digital certificates\" is used. \"Digital certificates\" are explained in more detail elsewhere in this app.</string>
    <string name="PKC56">This concludes the explanation of the public-key cryptosystem.</string>
    <string name="PKC6">"Let's say that party A wants to send data to party B over the internet."</string>
    <string name="PKC7">First, the receiver (party B) creates a public key and a secret key.</string>
    <string name="PKC8">The public key is sent to party A.</string>
    <string name="PKC9">Party A uses the public key they received from party B and encrypts the data.</string>
    <string name="PageRank">PageRank</string>
    <string name="PageRank0">\"PageRank\" is an algorithm used to determine the order of results found on a search site.</string>
    <string name="PageRank1">The story of Google becoming a global corporation by using this algorithm in their search engine is quite famous.</string>
    <string name="PageRank10">"We'll give the pages that have no links pointing to them a score of 1."</string>
    <string name="PageRank100">If we view this activity from the space of the internet, it looks as if web surfers...</string>
    <string name="PageRank101">are repeatedly teleporting to completely unrelated webpages after moving between an unspecified number of related ones.</string>
    <string name="PageRank11">The score of a page with links pointing to it is the combined score of the pages pointing to it.</string>
    <string name="PageRank12">However, when there are links to multiple pages...</string>
    <string name="PageRank13">the link score is distributed equally among them.</string>
    <string name="PageRank14">"In PageRank's way of thinking, a link from a highly-linked webpage has high value."</string>
    <string name="PageRank15">The page in the center of this diagram has links pointing to it from three independent pages, so its score is 3.</string>
    <string name="PageRank16">The topmost page has a high score because it has a link pointing to it from a page with a score of 3.</string>
    <string name="PageRank17">"Out of the six pages in this diagram, it's determined that the most important one is the topmost page."</string>
    <string name="PageRank18">This is the basic thinking behind PageRank.</string>
    <string name="PageRank19">With this method, a problem arises when links form a loop.</string>
    <string name="PageRank2">Up until that point, the order of search results was determined by focusing on search keywords and their relationship to sentences within the webpage.</string>
    <string name="PageRank20">If you calculate the score of each page in order...</string>
    <string name="PageRank24">as you can see, it loops infinitely, and the scores of the pages in the loop increase without end.</string>
    <string name="PageRank25">This loop problem is resolved using a calculation method called the \"random surfer model\".</string>
    <string name="PageRank26">"Let's think about how a person looks at webpages when surfing the net."</string>
    <string name="PageRank27">"Let's say that on one occasion, they visit an interesting-sounding webpage discussed in a magazine. Starting from this lower left page..."</string>
    <string name="PageRank28">they follow a link and move to a different page...</string>
    <string name="PageRank29">After viewing a few pages, they lose interest...</string>
    <string name="PageRank3">"With this method, it isn't taken into consideration whether or not a webpage contains useful information. Therefore, you couldn't say the search results had very high accuracy."</string>
    <string name="PageRank30">and stop surfing for the time being.</string>
    <string name="PageRank31">Then, on another day, they start their surfing on a completely different webpage recommended by a friend.</string>
    <string name="PageRank32">Following a link, they move to a different page...</string>
    <string name="PageRank33">and stop surfing once they lose interest.</string>
    <string name="PageRank34">And so the action repeats of starting by looking at one webpage and moving to a number of others before stopping.</string>
    <string name="PageRank35">If we define the actions of web surfers, we get something like the following.</string>
    <string name="PageRank36">Probability 1-α is the probability that 1 link among those on the current page will be chosen.</string>
    <string name="PageRank37">Probability α is the probability that the person will teleport to some other page.</string>
    <string name="PageRank38">"As an example, in this explanation we'll make α, the probability of teleportation, 15%."</string>
    <string name="PageRank39">"Let's try simulating the transition between pages according to this definition."</string>
    <string name="PageRank4">"PageRank is an algorithm that calculates the value of a webpage from the link structure between pages. Let's take a closer look at how it works up until calculations are made."</string>
    <string name="PageRank40">"As before, we'll consider what happens when the links form a loop."</string>
    <string name="PageRank41">The number on each page represents the number of times the web surfer has visited that page.</string>
    <string name="PageRank42">"Currently, since we haven't begun the simulation, all of the numbers are 0."</string>
    <string name="PageRank43">Running the simulation according to the definition, a difference develops in the number of visits to each page.</string>
    <string name="PageRank49">"Let's speed up the passage of time."</string>
    <string name="PageRank5">"Let's say the squares are webpages, and the arrows represent the links between them."</string>
    <string name="PageRank50">We ran the simulation until the total number of page visits reached 1000.</string>
    <string name="PageRank51">Expressing the results as percentages gives us the numbers in the diagram.</string>
    <string name="PageRank52">We can say that these values express the probability that someone is viewing the page at a given point in time.</string>
    <string name="PageRank53">"Using these values for webpage scores is the random surfer model's method."</string>
    <string name="PageRank54">As you can see, by using this method we can calculate a score even if the links create a loop.</string>
    <string name="PageRank55">"In reality, more practical calculation methods are used rather than simulations. Now we'll introduce those."</string>
    <string name="PageRank56">"Let's try calculating the score for each page in a complex network of links like in this diagram."</string>
    <string name="PageRank57">"First, we set each page's initial score."</string>
    <string name="PageRank58">The scores are set equally so that all of them add up to 1.</string>
    <string name="PageRank59">"Next, we'll find the probabilities of a web surfer being at each page after moving once."</string>
    <string name="PageRank6">This diagram shows that the bottom 3 pages contain links to the 1 top page.</string>
    <string name="PageRank60">"We'll express the probability of being at A after n moves as PAn. Likewise, the probability of being at B after n moves is PBn."</string>
    <string name="PageRank61">"As an example, let's find the probability of the web surfer being at A after moving 1 time (PA1)."</string>
    <string name="PageRank62">One scenario for being at A is that the person at C chooses to move, not teleport...</string>
    <string name="PageRank63">and chooses A, not B, as their destination.</string>
    <string name="PageRank64">The probability of someone being at C during the initial state (when 0 moves have been made) is PC0 (equal to 0.25).</string>
    <string name="PageRank65">Furthermore, the probability of the person at C choosing to move is 1-α, and the probability of choosing A from either A or B is 0.5.</string>
    <string name="PageRank66">Therefore, the probability of moving from C to A is PC0 x (1-α) x 0.5.</string>
    <string name="PageRank67">Another scenario for being at A is that the person at any one of the pages A-D chooses to teleport...</string>
    <string name="PageRank68">and chooses A as their teleportation destination.</string>
    <string name="PageRank69">The probability of the person at any one of the pages, A-D, choosing to teleport is α.</string>
    <string name="PageRank7">In the PageRank algorithm, the more links a webpage has pointing to it, the more important that page is determined to be.</string>
    <string name="PageRank70">Furthermore, the probability of A being chosen as the teleportation destination is 0.25.</string>
    <string name="PageRank71">Therefore, the probability of teleporting to A is α x 0.25.</string>
    <string name="PageRank72">From the aforementioned probabilities, we find that the probability of being at A after moving 1 time (PA1) is equal to PC0 x (1-α) x 0.5 + α x 0.25.</string>
    <string name="PageRank73">Making the substitutions PC0 = 0.25 and α = 0.15, we calculate PA1 = 0.14375.</string>
    <string name="PageRank74">In the same manner, we calculate the probabilities of being at B, C, and D, and update the values.</string>
    <string name="PageRank75">The results are displayed in the diagram.</string>
    <string name="PageRank76">"Next, we'll find the probabilities of a web surfer being at each page after moving 2 times."</string>
    <string name="PageRank77">The results are displayed in the diagram.</string>
    <string name="PageRank78">We repeat the same calculations, and the probability of someone being at each page starts to approach a fixed value.</string>
    <string name="PageRank79">Once the values have settled, calculations are complete.</string>
    <string name="PageRank8">"Here, it's determined that the top page is the most important."</string>
    <string name="PageRank80">The values calculated in this way are the scores for each page.</string>
    <string name="PageRank81">"Finally, we'll check to see if these PageRank values match the weighted link calculations we first covered."</string>
    <string name="PageRank82">"Using the same methods as before, we'll try calculating the scores for the link structure in the diagram."</string>
    <string name="PageRank83">"Since the values are rounded, they don't all add up to 1, but you can see that the ratio is close to the previous results."</string>
    <string name="PageRank84">"Let's calculate the scores for this link structure as well."</string>
    <string name="PageRank85">These too are close to the ratios we got before.</string>
    <string name="PageRank86">"In this way, the PageRank system foregoes weighted links in favor of webpages' probabilities of being visited when making calculations."</string>
    <string name="PageRank87">In reality, the order of Google search results is not arrived at by PageRank alone.</string>
    <string name="PageRank88">"However, that doesn't change the fact that the PageRank algorithm was revolutionary in its two concepts..."</string>
    <string name="PageRank89">those of calculating webpage values from link structures and being able to carry out calculations even when links form loops.</string>
    <string name="PageRank9">"In reality, each webpage's importance is calculated into a numeric value. First, let's explain the basic idea behind the calculation method."</string>
    <string name="PageRank90">This concludes the explanation of PageRank.</string>
    <string name="PageRankDescription">\"PageRank\" is an index used to determine the display order of search engine results. You can study this topic after purchasing all of the algorithms.</string>
    <string name="PrimalityTest">Primality Test</string>
    <string name="PrimalityTest0">A \"primality test\" is a method to determine whether or not a natural number is a prime number.</string>
    <string name="PrimalityTest1">A prime number is a natural number (n > 1) that has no divisor but 1 and itself.</string>
    <string name="PrimalityTest100">"Before we enter an explanation of the primality tests, let's explain the mod operation."</string>
    <string name="PrimalityTest101">The mod operation is an operation that finds the remainder of a division.</string>
    <string name="PrimalityTest102">For A mod B, we get C, the remainder of A divided by B.</string>
    <string name="PrimalityTest103">"Let's show an example operation using concrete numbers."</string>
    <string name="PrimalityTest17">In other words, the result means that 3599 is not a prime number.</string>
    <string name="PrimalityTest18">"However, this method takes more time as the number to be evaluated for primality gets bigger, and isn't realistic."</string>
    <string name="PrimalityTest19">The \"Fermat primality test\" is a method of addressing this problem.</string>
    <string name="PrimalityTest2">RSA encryption, an often-used modern encryption technique, handles very large prime numbers.</string>
    <string name="PrimalityTest20">The Fermat primality test is called a method of determining probabilistic primes, and determines whether the probability of primality is high.</string>
    <string name="PrimalityTest21">"As prerequisite knowledge, let's look at the nature of prime numbers."</string>
    <string name="PrimalityTest22">"As an example, let's think about the nature of the prime number 5."</string>
    <string name="PrimalityTest23">The results of taking each number smaller than 5 to the power of 5 are as shown in the diagram.</string>
    <string name="PrimalityTest28">Next, we perform the mod operation on each number to find their remainder when divided by 5...</string>
    <string name="PrimalityTest29">The results of the calculation are as shown in the diagram.</string>
    <string name="PrimalityTest3">Primality tests play a crucial role in RSA encryption.</string>
    <string name="PrimalityTest30">When we examine the original numbers and their remainders, we find that they match.</string>
    <string name="PrimalityTest31">From this, at least for the prime number 5, we see that the formula in the diagram works.</string>
    <string name="PrimalityTest32">"This time, we'll consider the composite number 6."</string>
    <string name="PrimalityTest33">"A \"composite number\" means a natural number that isn't a prime number. The number 6 can be expressed as 2 x 3, so it isn't a prime number."</string>
    <string name="PrimalityTest34">When we perform the same calculations...</string>
    <string name="PrimalityTest4">"Then, as an example, let's judge whether or not the number 3599 is a prime number."</string>
    <string name="PrimalityTest41">"we see that in the cases of 2 and 5, the original numbers don't match their remainders."</string>
    <string name="PrimalityTest42">This proves that as conjectured, the formula in the diagram works not just for 5, but for all primes p.</string>
    <string name="PrimalityTest43">"This is called \"Fermat's little theorem\"."</string>
    <string name="PrimalityTest44">"We call the method for determining prime numbers based on whether or not they satisfy Fermat's little theorem the Fermat primality test."</string>
    <string name="PrimalityTest45">"Let's determine whether the number 113 is a prime number or not using the Fermat primality test."</string>
    <string name="PrimalityTest46">Three numbers smaller than 113 were chosen at random.</string>
    <string name="PrimalityTest47">After taking these numbers to the power of 113, we divide them by 113 and get their remainders.</string>
    <string name="PrimalityTest48">"In every number's case, the original number matches the remainder."</string>
    <string name="PrimalityTest49">The more times matches are confirmed, the higher the probability of primality.</string>
    <string name="PrimalityTest5">"One possible method is to divide 3599 by numbers greater than 2, in order, seeing if it's divisible by each one."</string>
    <string name="PrimalityTest50">However, confirming every number smaller than p takes a lot of time.</string>
    <string name="PrimalityTest51">In practice, after checking a certain amount of numbers, if the probability of primality is high enough, the number is said to be a probable prime.</string>
    <string name="PrimalityTest52">As an example, an improved version of the Fermat primality test called the Miller-Rabin primality test is used for determining prime numbers in RSA encryption...</string>
    <string name="PrimalityTest53">but, if after repeating the test, the probability of a number not being prime is lower than 0.5 to the power of 80, that number is considered a prime number.</string>
    <string name="PrimalityTest54">"Besides, even if a number fully satisfies the Fermat primality test, it isn't confirmed to be a prime number."</string>
    <string name="PrimalityTest55">If the number being tested is a prime number, it will fully satisfy the Fermat primality test.</string>
    <string name="PrimalityTest56">On the other hand, while composite numbers will usually be caught by the Fermat primality test when tested...</string>
    <string name="PrimalityTest57">there are composite numbers that, while extremely rare, fully satisfy the Fermat primality test just like prime numbers do.</string>
    <string name="PrimalityTest58">"For example, let's consider the number 561."</string>
    <string name="PrimalityTest59">The number 561 is a composite number that can be expressed by 3 x 187, or 11 x 51, and so on, and is not a prime number.</string>
    <string name="PrimalityTest6">\"Divisible\" means that the mod operation, an operation that finds the remainder of a division, results in a 0.</string>
    <string name="PrimalityTest60">However, it satisfies the Fermat primality test.</string>
    <string name="PrimalityTest63">This kind of composite number is called a \"Carmichael number\", or \"absolute Fermat pseudoprime\".</string>
    <string name="PrimalityTest64">The diagram shows some Carmichael numbers in order starting from the smallest ones, and we can see that there are very few of them.</string>
    <string name="PrimalityTest65">"It's correct to say that prime numbers fully satisfy the Fermat primality test, but we can't say that a number is a prime number just because it fully satisfied the Fermat primality test."</string>
    <string name="PrimalityTest66">At the most, the Fermat primality test is a method of determining probabilistic primes.</string>
    <string name="PrimalityTest67">"However, it is used in most cases because there aren't any other efficient determination methods."</string>
    <string name="PrimalityTest68">This concludes the explanation of a primality test.</string>
    <string name="PrimalityTest7">The square root of 3599 is 59.99..., so running the numbers 2 to 59 through the mod operation should be enough.</string>
    <string name="PrimalityTest8">As a result of actually carrying out the mod operation, we see that 3599 is divisible by 59.</string>
    <string name="PrimalityTestDescription">In the \"Primality Test\" entry, we explain the Fermat primality test, a method of determining probabilistic primes. You can study this topic after purchasing all of the algorithms.</string>
    <string name="Queue">队列</string>
    <string name="Queue0">\"Queues\" are one type of data structure.</string>
    <string name="Queue1">Queues are also known as \"waiting lines\", and as the name suggests, they can be easily imagined as a group of people waiting in line.</string>
    <string name="Queue10">This concludes the explanation of queues.</string>
    <string name="Queue2">In queues, the sooner a person lines up, the higher their priority.</string>
    <string name="Queue3">When adding data to a queue, the data is placed at the end.</string>
    <string name="Queue5">We use the term \"enqueue\" to refer to the act of adding data to a queue.</string>
    <string name="Queue6">"When extracting data from a queue, the data that's been in the queue the longest is removed first."</string>
    <string name="Queue8">We use the term \"dequeue\" to refer to the act of extracting data from a queue.</string>
    <string name="Queue9">This method of extracting the initially added data first is called \"First In First Out\", or \"FIFO\" for short.</string>
    <string name="QuickSort">快速排序</string>
    <string name="QuickSort0">\"Quicksort\" is one algorithm used to sort a sequence of numbers.</string>
    <string name="QuickSort1">"One characteristic of quicksort is that it involves fewer comparisons and swaps than other algorithms, so it's able to sort quickly in many cases."</string>
    <string name="QuickSort100">"Let's take a look at the algorithm in action."</string>
    <string name="QuickSort101">A marker will be placed on the pivot for easy reference.</string>
    <string name="QuickSort102">Next, a left marker will be placed on the leftmost number, and a right marker will be placed on the rightmost number.</string>
    <string name="QuickSort103">The quicksort algorithm uses these markers to repeatedly perform rounds of operations recursively.</string>
    <string name="QuickSort105">In this way, the left marker acts to find numbers greater than or equal to the pivot, and the right marker finds numbers less than the pivot.</string>
    <string name="QuickSort106">By swapping the numbers, you can gather numbers that are less than the pivot on the left side of the sequence, and numbers that are greater than or equal to the pivot on the right side.</string>
    <string name="QuickSort107">This completes the first round of operations.</string>
    <string name="QuickSort11">4 is less than 6, so the marker stopped moving.</string>
    <string name="QuickSort12">"When both left and right markers have stopped, the markers' numbers are swapped."</string>
    <string name="QuickSort13">After the swap, the left marker continues moving to the right.</string>
    <string name="QuickSort14">Like before, the left marker moves until it reaches a number greater than or equal to the pivot number.</string>
    <string name="QuickSort18">9 is greater than or equal to 6, so the marker stopped moving.</string>
    <string name="QuickSort19">Once again, the right marker is moved to the left.</string>
    <string name="QuickSort2">The first operation targets the entire sequence of numbers.</string>
    <string name="QuickSort21">Movement also stops when the right marker runs into the left marker.</string>
    <string name="QuickSort22">"When both left and right markers stop and they're in the same position, that number is swapped with the pivot number."</string>
    <string name="QuickSort23">The number occupied by both the left and right markers is considered fully sorted.</string>
    <string name="QuickSort24">With one round of operations...</string>
    <string name="QuickSort25">we were able to put numbers smaller than the pivot to the left of the pivot,</string>
    <string name="QuickSort26">and numbers larger than the pivot to the right of the pivot.</string>
    <string name="QuickSort27">Another round of operations will be performed recursively on both sequences created by the division.</string>
    <string name="QuickSort28">Next, operations will be performed on the sequence to the left of the division.</string>
    <string name="QuickSort29">The 3 markers are placed.</string>
    <string name="QuickSort3">A number is chosen as a reference for sorting. This number is called the \"pivot\".</string>
    <string name="QuickSort30">The same operation as before is performed.</string>
    <string name="QuickSort4">The left marker will move to the right.</string>
    <string name="QuickSort40">The round of operations is complete...</string>
    <string name="QuickSort41">and we were able to divide the sequence into numbers smaller than the pivot to the left of the pivot...</string>
    <string name="QuickSort42">and numbers larger than the pivot to the right of the pivot.</string>
    <string name="QuickSort43">Another round of operations is repeated recursively.</string>
    <string name="QuickSort44">The left side of the division will now undergo the operation.</string>
    <string name="QuickSort45">When the target sequence only has one number, it is considered fully sorted.</string>
    <string name="QuickSort47">Now operations will be performed on the right side created by the 2nd round of operations.</string>
    <string name="QuickSort48">The 3 markers are placed.</string>
    <string name="QuickSort49">The left marker will move to the right.</string>
    <string name="QuickSort50">"Even when the left marker runs into the right marker, it doesn't stop. It differs from the right marker in this respect."</string>
    <string name="QuickSort51">When the left marker reaches the rightmost edge of the target sequence, it stops.</string>
    <string name="QuickSort52">This means that the pivot number is the largest number in the target sequence.</string>
    <string name="QuickSort53">Next, the right marker would be moved, but when it has been passed by the left marker, it finishes without moving.</string>
    <string name="QuickSort54">When the left marker has reached the rightmost edge of the target sequence, the pivot number is considered fully sorted, and the round of operations ends.</string>
    <string name="QuickSort55">Hereafter, the same operations will be repeated until all of the numbers are fully sorted.</string>
    <string name="QuickSort6">When the left marker reaches a number greater than or equal to the pivot number, it stops moving.</string>
    <string name="QuickSort7">In this case, 8 is greater than or equal to 6, so the marker stopped moving.</string>
    <string name="QuickSort8">Next, the right marker will move to the left.</string>
    <string name="QuickSort83">All of the numbers have been fully sorted.</string>
    <string name="QuickSort84">This concludes the explanation of quicksort.</string>
    <string name="QuickSort9">When the right marker reaches a number less than the pivot number, it stops.</string>
    <string name="QuickSort99">The pivot is normally a number chosen at random. This time, for convenience, the rightmost number will be chosen as the pivot.</string>
    <string name="QuickSortDescription">\"Quicksort\" in unique in its low number of comparisons and swaps. You can study this topic after purchasing all of the algorithms.</string>
    <string name="RateThisApp">为本应用打分！</string>
    <string name="RecursionSection">递归</string>
    <string name="Restore">恢复购买记录</string>
    <string name="RestoreAlert">Purchase records have been confirmed, and will be restored. You will not incur any charges.</string>
    <string name="RestoreBuyingLog">恢复购买记录</string>
    <string name="RestoreSuccessed">购买记录已恢复</string>
    <string name="ReviewConfirmation">打开苹果应用商店</string>
    <string name="ReviewConfirmationAndroid">打开谷歌应用商店</string>
    <string name="RunLength">游程编码(RLE)</string>
    <string name="RunLength0">"Let's try encoding an image drawn using three colors on a 5x5 grid."</string>
    <string name="RunLength1">"First, we'll use a simple method."</string>
    <string name="RunLength10">These operations are called \"compression\" and \"decompression\".</string>
    <string name="RunLength11">Run-length encoding is well-suited for some types of data, but not so well-suited for others.</string>
    <string name="RunLength12">If we look closely at the encoded line, we see that, as a whole, the number of characters has decreased...</string>
    <string name="RunLength13">"but the parts that don't have the same color consecutively actually end up increasing in character count after being run-length encoded."</string>
    <string name="RunLength14">For example, if we apply run-length encoding to data like this, which is low in consecutive characters...</string>
    <string name="RunLength15">the data doubles to 50 characters.</string>
    <string name="RunLength16">Conversely, when we apply run-length encoding to data with continuity like this...</string>
    <string name="RunLength17">the encoded data is 10 characters. Compared to the original 25, it has been compressed a considerable amount.</string>
    <string name="RunLength18">"As you can see, depending on the target data, there are times when the compression is effective, and times when it isn't."</string>
    <string name="RunLength19">Therefore, a variety of strategies are necessary, such as only using run-length encoding for data with more than a fixed number of consecutive characters.</string>
    <string name="RunLength2">"We've assigned a letter to each of the colors, Y for Yellow, G for Green, and B for Blue."</string>
    <string name="RunLength20">"As an example, let's consider using run-length encoding on a monochrome fax."</string>
    <string name="RunLength21">If we simply assign a W for white and B for black to express each square when sending this image, the result will be 25 characters.</string>
    <string name="RunLength22">"To keep the amount of traffic down, let's try compressing the data with run-length encoding."</string>
    <string name="RunLength23">The result gives us 26 characters, an increase of one, so using run-length encoding here was meaningless.</string>
    <string name="RunLength24">However, a monochrome image uses only two colors, black and white.</string>
    <string name="RunLength25">Therefore, if we reach the end of a run of white squares, the next square will always be black.</string>
    <string name="RunLength26">It seems that we can restore the image from the code even without the letters W and B.</string>
    <string name="RunLength27">The W and B were omitted, resulting in a total of 13 characters, a compression about half the size.</string>
    <string name="RunLength28">However, we need to establish a rule so that we know the first number in the code refers to a consecutive number of white squares.</string>
    <string name="RunLength29">With such a rule, we can correctly restore the image from the code.</string>
    <string name="RunLength3">As a result of transforming the rows into Ys, Gs, and Bs one line at a time starting from the upper left, we were able to encode the figure into a line of 25 letters.</string>
    <string name="RunLength30">So, how should we go about encoding an image like the following?</string>
    <string name="RunLength31">In contrast to the previous image, the first square is black, not white.</string>
    <string name="RunLength32">"For the time being, we've tried encoding the image using the same method as before."</string>
    <string name="RunLength33">The first number in the code, 6, refers to the consecutive number of black squares...</string>
    <string name="RunLength34">"but that doesn't follow our rule that states \"the first number in the code refers to a consecutive run of white squares\"."</string>
    <string name="RunLength35">If we restore the image from the current code, it will result in an image with black and white inverted.</string>
    <string name="RunLength36">So that we absolutely follow our \"the first number in the code refers to a consecutive number of white squares\" rule, a 0 was added to the beginning of the code.</string>
    <string name="RunLength37">This tells us that there are 0 white squares, in other words no white squares, at the beginning of the image.</string>
    <string name="RunLength38">By adding the 0 to the beginning of the code, the number of letters in the code increased by one, but we were able to compress the data while following our established rule.</string>
    <string name="RunLength39">In general, you can say that run-length encoding is geared toward compressing image data more than text, which lacks consecutively repeating data.</string>
    <string name="RunLength4">"Next, using run-length encoding on the image, let's try expressing it in less than 25 letters."</string>
    <string name="RunLength40">What is desired is a strategy that exhibits superior compression results in either case.</string>
    <string name="RunLength41">This concludes the explanation of run-length encoding.</string>
    <string name="RunLength5">\"Run-length encoding\" is a method of encoding that makes a code and the number of times it repeats into a set.</string>
    <string name="RunLength6">For example, we can express the first \"YYYY\" part as \"Y4\", which is two characters shorter.</string>
    <string name="RunLength7">The same operation repeats, completing the run-length encoding.</string>
    <string name="RunLength8">As a result, the code was five characters shorter, compressed to 20.</string>
    <string name="RunLength9">"If it's known that the image has 5 squares per row, the original image can be extracted from the code."</string>
    <string name="SecurityBase">加密基础</string>
    <string name="SecurityBase0">Why exactly do we need encryption technologies in the modern internet world?</string>
    <string name="SecurityBase1">"Let's say party A is attempting to send some data over the internet to party B."</string>
    <string name="SecurityBase10">"If you encrypt the data, there's nothing to worry about even if a malicious third party intercepts it."</string>
    <string name="SecurityBase11">"Therefore, encryption technology has become very important in today's internet world."</string>
    <string name="SecurityBase12">"Next, let's take a closer look at exactly what kinds of operations are involved with encryption."</string>
    <string name="SecurityBase13">First, regardless of the type of data, the computer manages it as binary, which uses the digits 0 and 1.</string>
    <string name="SecurityBase14">There are a variety of data formats, such as text, music, and videos...</string>
    <string name="SecurityBase15">but inside a computer, all of the data is handled as a binary value.</string>
    <string name="SecurityBase150">Here we have explained the necessity of encryption technology, the idea of data being treated as numeric values, and that encryption is a numeric calculation.</string>
    <string name="SecurityBase16">"Let's think about data encryption with this in mind."</string>
    <string name="SecurityBase17">To a computer, data is a meaningful sequence of numbers.</string>
    <string name="SecurityBase18">"While ciphertext is also handled as a sequence of numbers, they're random numbers that the computer can't decipher."</string>
    <string name="SecurityBase19">"Encryption means performing some kind of calculation on data and turning it into numbers that a computer can't decipher."</string>
    <string name="SecurityBase2">The data is delivered to party B, passing through a variety of networks and devices on the internet.</string>
    <string name="SecurityBase20">"A \"key\" is used for the encryption's numeric calculations."</string>
    <string name="SecurityBase21">This key is also made up of numeric values.</string>
    <string name="SecurityBase22">"In other words, by using a key for numeric calculations, encryption converts the data into something that can't be read."</string>
    <string name="SecurityBase23">Conversely, by using a key for numeric calculations, decryption changes the ciphertext back into its original data.</string>
    <string name="SecurityBase24">"As an example, let's take a closer look at what happens when the \"XOR\" calculation method is used with the data and key values pictured."</string>
    <string name="SecurityBase25">XOR (exclusive or) is an operation that makes calculations based on this \"truth table\".</string>
    <string name="SecurityBase26">One characteristic of XOR is that these expressions hold true.</string>
    <string name="SecurityBase27">That means if C is the result of the XOR calculation on values A and B,</string>
    <string name="SecurityBase28">you can make an XOR calculation once more using C and either A or B to obtain the other value.</string>
    <string name="SecurityBase29">Using the key to make an XOR calculation on the data...</string>
    <string name="SecurityBase3">Thus, if the data is sent as is...</string>
    <string name="SecurityBase30">we were able to obtain this ciphertext.</string>
    <string name="SecurityBase31">"Now, let's try to decrypt the ciphertext."</string>
    <string name="SecurityBase32">Using the key once again to make an XOR calculation on the ciphertext...</string>
    <string name="SecurityBase33">we were able to obtain the original data.</string>
    <string name="SecurityBase34">As you can see, the same key is used for encryption and decryption when using the XOR calculation method for encrypting data.</string>
    <string name="SecurityBase35">This concludes the explanation of encryption basics.</string>
    <string name="SecurityBase4">"there's a chance it could be intercepted by a malicious third party."</string>
    <string name="SecurityBase5">"For this reason, it's necessary to encrypt data you want to remain private before you send it."</string>
    <string name="SecurityBase6">"Data that's been encrypted is called \"ciphertext\"."</string>
    <string name="SecurityBase7">The ciphertext is sent to party B.</string>
    <string name="SecurityBase8">Party B decrypts the ciphertext received from party A and acquires the original data.</string>
    <string name="SecurityBase9">This process of returning encrypted data to its original state is called \"decryption\".</string>
    <string name="SecurityBasic">安全基础</string>
    <string name="SecurityBasic0">When exchanging data over the internet, the data reaches the other party after passing through a variety of networks and devices.</string>
    <string name="SecurityBasic1">Because of that, security technology becomes essential to using the internet safely.</string>
    <string name="SecurityBasic10">This problem is called \"spoofing\".</string>
    <string name="SecurityBasic11">"\#3: Even if the transmission of party A's message to party B was completed..."</string>
    <string name="SecurityBasic12">"there's a chance that party X had overwritten the message during transmission."</string>
    <string name="SecurityBasic13">This problem is called \"falsification\".</string>
    <string name="SecurityBasic14">"In addition to intentional falsification by third parties, there's also the chance that the delivered message was damaged by some malfunction during transmission."</string>
    <string name="SecurityBasic15">\#4: While party B believes they received a message from party A...</string>
    <string name="SecurityBasic16">if the sender of the message, party A, had some malicious intent...</string>
    <string name="SecurityBasic17">"there's a chance that party A later insists \"That's not the message I sent!\"."</string>
    <string name="SecurityBasic18">When something like this happens, the internet is no longer a viable medium for business transactions or contracts.</string>
    <string name="SecurityBasic19">This problem is called \"repudiation\".</string>
    <string name="SecurityBasic2">"To begin, let's take a look at the 4 prominent problems that can occur when data is being sent across the internet."</string>
    <string name="SecurityBasic20">"We've introduced the four prominent problems."</string>
    <string name="SecurityBasic21">Furthermore, these problems are not limited to exchanges between people, but can also occur while browsing a website.</string>
    <string name="SecurityBasic22">"Next, let's take a brief look at what types of security technologies are available to solve these problems."</string>
    <string name="SecurityBasic23">To prevent the first problem of interception, we use \"encryption\" technology.</string>
    <string name="SecurityBasic24">To prevent the second problem of spoofing, we use either \"message authentication codes\"...</string>
    <string name="SecurityBasic25">or \"digital signature\" technologies.</string>
    <string name="SecurityBasic26">Likewise, to prevent the third problem of falsification, we use either message authentication codes...</string>
    <string name="SecurityBasic27">or digital signature technologies.</string>
    <string name="SecurityBasic28">This digital signature technology is also useful in preventing the 4th problem, repudiation.</string>
    <string name="SecurityBasic29">Putting it all together in a chart gives us this diagram.</string>
    <string name="SecurityBasic3">\#1: When party A tries to send a message to party B...</string>
    <string name="SecurityBasic30">"Furthermore, \"digital certificate\" technology also serves to solve the problem inherent in digital signature technology of being unable to verify the public key's owner."</string>
    <string name="SecurityBasic31">All of these security technologies are individually explained in more detail elsewhere in this app.</string>
    <string name="SecurityBasic32">This concludes the explanation of security basics.</string>
    <string name="SecurityBasic4">"there's a possibility that the message contents are intercepted by party X during transmission."</string>
    <string name="SecurityBasic5">This problem is called \"interception\".</string>
    <string name="SecurityBasic6">\#2: Even though party A meant for the message to be sent to party B...</string>
    <string name="SecurityBasic7">"there's a chance that party X was posing as party B."</string>
    <string name="SecurityBasic8">Conversely, although party B believes they received a message from party A...</string>
    <string name="SecurityBasic9">"there's a chance that party X was posing as party A."</string>
    <string name="SecuritySection">安全</string>
    <string name="SelectionSort">选择排序</string>
    <string name="SelectionSort0">\"选择排序\"是一种用来对数列进行排序的算法</string>
    <string name="SelectionSort1">先用线性搜索找到数列中的最小值所在的位置(关于\"线性搜索\"的详细讲解可以在该算法主题里看到).</string>
    <string name="SelectionSort2">然后我们把这个最小值和数列左边第一个元素交换位置,然后我们认为第一个元素已经被排好序了.</string>
    <string name="SelectionSort3">当然,如果碰巧最小值就是在最左边的位置上,那我们就不用执行交换的操作了.</string>
    <string name="SelectionSort4">重复相同的操作,直到所有的数字都被排好序.</string>
    <string name="SelectionSort6">排序完成.</string>
    <string name="SelectionSort7">这就是选择搜索.</string>
    <string name="Setting">设置</string>
    <string name="SettingNotShowUnreadButtons">隐藏“未读”标志</string>
    <string name="Share">分享和评分</string>
    <string name="ShareOnFacebook">在Facebook上分享</string>
    <string name="ShareOnTwitter">在Twitter上分享</string>
    <string name="SortSection">排序</string>
    <string name="Stack">栈</string>
    <string name="Stack0">\"栈\"是一种数据结构.</string>
    <string name="Stack1">The structure of a stack can be easily imagined as a pile of objects stacked vertically.</string>
    <string name="Stack10">This concludes the explanation of stacks.</string>
    <string name="Stack2">When extracting these objects, they are extracted in order from the top down.</string>
    <string name="Stack3">When adding data to a stack, the data is put into the lowest available location.</string>
    <string name="Stack5">We use the term \"push\" to refer to the act of adding data to a stack.</string>
    <string name="Stack6">When extracting data from a stack, the most recently added data is removed first.</string>
    <string name="Stack8">We use the term \"pop\" to refer to the act of extracting data from a stack.</string>
    <string name="Stack9">This method of extracting the most recently added data first is called \"Last In First Out\", or \"LIFO\" for short.</string>
    <string name="ThankYouForUnlocking">非常感谢你购买了我们的算法主题(包括动画演示和讲解)，希望本应用可以帮助你更好地理解与学习算法。</string>
    <string name="ToSendUs">如果要告诉我们在应用中出现的bug，请使用列表中的\"反馈\"功能</string>
    <string name="Unlock">购买所有算法主题</string>
    <string name="UnlockSuccessed">购买算法主题成功！</string>
    <string name="WEB">浏览器</string>
    <string name="YouCanLearnAfter">\"%@\" 在购买后可以学习所有的算法主题.</string>
    <string name="YouCanLearnAfterAndroid">\"%s\" 在购买后可以学习所有的算法主题.</string>
    <string name="YouCanRestore">"如果你已经购买了所有的算法，那么在你恢复了购买记录后即可浏览所有的主题。"</string>
    <string name="app_name">算法详解</string>
    <string name="en">English</string>
    <string name="ja">Japanese</string>
    <string name="abc_font_family_body_1_material">sans-serif</string>
    <string name="abc_font_family_body_2_material">sans-serif-medium</string>
    <string name="abc_font_family_button_material">sans-serif-medium</string>
    <string name="abc_font_family_caption_material">sans-serif</string>
    <string name="abc_font_family_display_1_material">sans-serif</string>
    <string name="abc_font_family_display_2_material">sans-serif</string>
    <string name="abc_font_family_display_3_material">sans-serif</string>
    <string name="abc_font_family_display_4_material">sans-serif-light</string>
    <string name="abc_font_family_headline_material">sans-serif</string>
    <string name="abc_font_family_menu_material">sans-serif</string>
    <string name="abc_font_family_subhead_material">sans-serif</string>
    <string name="abc_font_family_title_material">sans-serif-medium</string>
    <string name="com.crashlytics.android.build_id">dae181b1-91db-494c-8d5e-52ba02597c38</string>
    <string name="facebook_app_id">512585652266435</string>
    <string name="ga_trackingId">UA-69263465-2</string>
    <string name="gcm_defaultSenderId">1011692044463</string>
    <string name="google_api_key">AIzaSyAHCAHiMsmhuv3tYFc3EOYtbjZ9DZ6Rops</string>
    <string name="google_app_id">1:1011692044463:android:2dd461f674022e95</string>
    <string name="google_crash_reporting_api_key">AIzaSyAHCAHiMsmhuv3tYFc3EOYtbjZ9DZ6Rops</string>
</resources>
